var tipuesearch = {"pages":[{"title":" ForSynth ","text":"ForSynth A small Fortran synthesizer to explore sound synthesis, sound effects, electronic music, algorithmic music, etc. But ForSynth could also be used for scientific data sonification , for acoustic simulations or for teaching programming in a fun way. Humbly follow the steps of Stockhausen, Kraftwerk and the Daft Punk (see the ELECTRONIC_MUSIC_HISTORY.md file). Features ForSynth is a semi-analog semi-digital studio: time is discretized (44100 samples/s) but the amplitude is coded as a Fortran real and digitized as a 16 bits signed integer only after the final mixing, when generating the output WAV file. You can use as many stereo tracks as you need. The track 0 is used for the final mix and some algorithms also use it as an auxilliary track. Do you know The Beatles used a 8 tracks tape recorder the first time in August 1968 to record Hey Jude ? The second song was Dear Prudence . Basic music theory elements (scales, circle of fifths, chords...). Various signals, Karplus-Strong algorithms (guitar and drums), bells. Envelopes generators: ADSR, fade in, fade out, exponentially decreasing envelope. Some audio effects: delay, fuzz, tremolo, reverse and autopan. Morse code support. Final mixing with the level and panoramic of each track. The API is documented with FORD: https://vmagnin.github.io/forsynth/ Various examples. You just need a modern Fortran compiler and a media player, whatever your OS. GPL-3.0-or-later license. If you are more interested by composing than sound synthesis, you may also be interested by its twin project ForMIDI . Compilation and execution You can easily build the project using the Fortran Package Manager fpm (https://github.com/fortran-lang/fpm) at the root of the project directory: $ fpm build Or if you don't have fpm, you can use the build.sh script (the examples will be built inside the build/ directory). Running the examples The examples can be found in the example/ directory. For example, the chords_and_melody.f90 example can be run with the command: $ fpm run --example chords_and_melody But you can also use the optimization flags of your compiler, for example with GFortran: $ fpm run --example chords_and_melody --flag \"-Ofast -static-libgfortran\" A WAV file was generated in the root directory of the project: $ file chords_and_melody.wav\nchords_and_melody.wav: RIFF ( little-endian ) data, WAVE audio, Microsoft PCM, 16 bit, stereo 44100 Hz\n$ hexdump -C chords_and_melody.wav 00000000 52 49 46 46 a4 ff 42 01 57 41 56 45 66 6d 74 20 | RIFF..B.WAVEfmt | 00000010 10 00 00 00 01 00 02 00 44 ac 00 00 10 b1 02 00 | ........D....... | 00000020 04 00 10 00 64 61 74 61 80 ff 42 01 3d 0e 3d 0e | ....data..B. = . = . | 00000030 56 03 56 03 d4 f5 d4 f5 9d 0e 9d 0e 91 f6 91 f6 | V.V............. | ... You can listen to your WAV using any media player, for example the SoX play command (or the ALSA command aplay ): $ play chords_and_melody.wav\n\nchords_and_melody.wav: File Size: 21 .2M Bit Rate: 1 .41M Encoding: Signed PCM Channels: 2 @ 16 -bit\nSamplerate: 44100Hz\nReplaygain: off Duration: 00 :02:00.00\n\nIn:2.32% 00 :00:02.79 [ 00 :01:57.21 ] Out:123k [ ! ===== | ===== ! ] Hd:0.0 Clip:0 You can also use Audacity or Sonic Visualiser to visualise your music, either as a waveform or a spectrogram. Contributing Post a message in the GitHub Issues tab to discuss the function you want to work on. Concerning coding conventions, follow the stdlib conventions:\nhttps://github.com/fortran-lang/stdlib/blob/master/STYLE_GUIDE.md When ready, make a Pull Request . Technical information Endianness A WAV comprises a header with metadata then the soundtracks in PCM (https://en.wikipedia.org/wiki/Pulse-code_modulation), written in little endian. This program asserts your machine is little endian. If you are big endian, please use the -fconvert=big-endian flag with gfortran, or -convert big_endian with ifort. Or contribute to the code to allow an automatic detection of endianness. https://fortran-lang.discourse.group/t/writing-a-binary-file-in-little-endian/719/4 https://en.wikipedia.org/wiki/Endianness WAV / RIFF format https://en.wikipedia.org/wiki/Resource_Interchange_File_Format https://en.wikipedia.org/wiki/WAV http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html Sound synthesis https://sites.google.com/site/learning4synthesizer/home https://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis Miscellaneous https://en.wikipedia.org/wiki/Morse_code Bibliography English Jean-Claude Risset, \"Computer music: why ?\" , 2003. Jean-Claude Risset, An Introductory Catalogue Of Computer Synthesized Sounds , Bell Telephone Laboratories Murray Hill, New Jersey, 1969. Dave Benson, Music - A Mathematical Offering , 531 pages, 2008. Jeffrey Hass, Introduction to Computer Music - An Electronic Textbook , Jacobs School of Music, Indiana University, 2023. David A. Jaffe and Julius O. Smith, “Extensions of the Karplus-Strong Plucked-String Algorithm.” Computer Music Journal 7, no. 2 (1983): 56. https://doi.org/10.2307/3680063. Kevin Karplus and Alex Strong, “Digital Synthesis of Plucked-String and Drum Timbres.” Computer Music Journal 7, no. 2 (1983): 43–55. https://doi.org/10.2307/3680062. Jarmo Lähdevaara, Science of Electric Guitars and Guitar Electronics. Helsinki, Finland: Books On Demand, 2012. Diana Deutsch, \"The Paradox of Pitch Circularity\"’. Acoustics Today 6, no. 3 (July 2010): 8–14. https://doi.org/10.1121/1.3488670. M.V. Mathews, \"The Digital Computer as a Musical Instrument\" , Science 142, no. 3592 (1963): 553–57. \"The First Computer Musician\" , by R. Luke DuBois, NYT, June 8, 2011. M.V. Mathews, F.R. Moore and J.-C. Risset, \"Computers and Future Music\" , Science, New Series, Vol. 183, No. 4122 (Jan. 25, 1974), pp. 263-268. Miguel Carvalho, Vincent Debut and Jose Antunes, \"Physical Modelling Techniques for the Dynamical Characterization and Sound Synthesis of Historical Bells\", Heritage Science (2021) 9:157, https://doi.org/10.1186/s40494-021-00620-2. French Vincent Magnin, \"Format WAV : créez des ondes sonores en C\" , GNU/Linux Magazine n°190, février 2016. Vincent Magnin, \"Format WAV : des sons de plus en plus complexes\" , GNU/Linux Magazine n°190, février 2016. Some sounds created with the C version of the program: http://magnin.plil.net/spip.php?article131 Laurent de Wilde, Les fous du son - D'Edison à nos jours , Editions Grasset et Fasquelle, 560 pages, 2016, ISBN 9782246859277. Laurent Fichet, Les théories scientifiques de la musique aux XIXe et XXe siècles , Vrin, 1996, ISBN 978-2-7116-4284-7. Guillaume Kosmicki , Musiques électroniques - Des avant-gardes aux dance floors , Editions Le mot et le reste, 2nd edition, 2016, 416 p., ISBN 9782360541928. Olivier Pernot, ELECTRO 100 - Les albums essentiels des musiques électroniques , Editions Le mot et le reste, 2016, 240 p., ISBN 978-2-36054-202-4. Bibliothèque Tangente n°11, Mathématiques et musique - des destinées parallèles , Paris : Éditions POLE, septembre 2022, ISBN 9782848842462. Blog Devenir Ingeson . An history of electronic music full of personal and geographical biases... Before modern electronics (The Electricity Fairy) Some ancestors of electronic instruments The telharmonium (1897). Patent US580035A . The intonarumori is an instrument created in 1913 by the futuristic composer Luigi Russolo. Russolo is the author of a manifesto on The Art of Noises (L'arte dei rumori) , a manifesto for futuristic music. French translation: http://luigi.russolo.free.fr/mani1.html ; http://luigi.russolo.free.fr/mani2.html ; http://luigi.russolo.free.fr/mani3.html ; http://luigi.russolo.free.fr/mani4.html George Antheil, Ballet Mécanique (1924). Piano, percussions and noises. The Theremin , a non-contact instrument invented in 1919. It is used from time to time by certain bands: Jimmy Page, Led Zeppelin guitarist: In the documentary It Might Get Loud (2008), he shows The Edge and Jack White how to use theremin to create sounds. A 1977 live . The Rolling Stones: \"2000 Light Years From Home\" , album Their Satanic Majesties Request (1967), mellotron and theremin. Sting . Jean-Michel Jarre (Monaco concert, 2011) . Ondes Martenot (1928) The Beach Boys, \"Good vibrations (1966)\" . Radiohead, \"How to disappear completely\" (live) Daft Punk feat. Paul Williams, \"Touch\" , Random Access Memories, 2013. Hammond organ (1935): Bob Marley & The Wailers - \"No Woman, No Cry\" (Live At The Rainbow 4th June 1977). Ondioline (1941) . Musique concrète Before music produced by electronic circuits, experiments were made in the 1940s with electroacoustic music and musique concrète , where (concrete) sounds were recorded on tape or vinyl and arranged and manipulated (the ancestor of sampling ): Pierre Schaeffer, 78 rpm with closed groove (1948) . Pierre Schaeffer, \"Etude aux chemins de fer\" (1948) . Iannis Xenakis, \"Diamorphoses\" (1957) . Pierre Henry, \"Psyché Rock\" , Messe pour le temps présent (1967). 50's: Stockhausen Elektronische Musik Studie I (1953) . Elektronische Musik Studie II (1954) . Telemusik (1966) . A more recent work, Oktophonie (1991) . 50's: misc Herbert Eimert, Klangstudie II (1952) . Luciano Berio, Perspectives, per nastro magnetico (1957) . Tom Dissevelt & Kid Baltan: Song of the Second Moon (1957) . Syncopation (1958? released in 1962) . Edgard Varèse, Poème électronique (1958). Else Marie Pade: Syv Cirkler (1958) . Faust (1962) . 50's: Forbidden Planet (1956) First film whose soundtrack (Louis & Bebe Barron) is entirely electronic: Robby . The great machine . Main Titles Overture . 60's: misc Daphne Oram, Pulse Persephone , 1965. The Oramics Machine - Oram’s ‘drawn sound’ synthesis and sequencing system . 60's: computers Music From Mathematics (I.B.M. 7090) , 2nd edition, DECCA, 1962. Contains especially a few pieces by Max Mathews (Bell Labs). 60's: some famous electric keyboards The Doors, \"When The Music's Over\" (1967) (Ray Manzarek is generally playing a Fender Rhodes electric piano keyboard bass and a Vox Continental combo organ). 60's: Moog synthesizers Wendy Carlos Switched-On Bach (1968) . A Clockwork Orange (Stanley Kubrick) theme (1971) . Popcorn (Gershon Kingsley, 1969) The first great success of electronic music . Popcorn, original by Kingsley (1969) . HotButter cover (1972) . M&H Band cover (1987) . Kingsley (2000) . Muse cover: Taratata (French TV), Oct. 2009 . Single (2010) . The Muppets cover (2010) . Other covers . Bernie Krause He was a student of Stockhausen. As a guitarist, he will work for Moog and learn about electronic music, before becoming a bio-acoustician: he will study soundscapes, record the sounds of nature, highlight their frequential and temporal organisation, then show the degradation over the decades of soundscapes and therefore of the corresponding ecosystems (https://www.wildsanctuary.com/). He also played with people like The Doors or George Harrison.). Paul Beaver & Bernard L. Krause - The Nonesuch Guide To Electronic Music (1968) . The Beatles ( Abbey Road, 1969) The Moog is used on the tracks \"Maxwell's Silver Hammer\", \"I Want You (She's So Heavy)\", \"Here Comes The Sun\", and \"Because\". \"Because\" . About modular synthesizers Before becoming digital, the first synthesizers were analogue and modular: each function corresponds to a button, the functions and modules are connected by cables (wave generators, envelope generators, low frequency oscillators, filters, sequencers...) Ideal to understand what a synthesizer is! Documentary 50th Anniversary of the Moog Modular Synthesizer (2014) . Documentary Back to the future sounds . Silver Apples, \"Dust\" (1968) . Eliane Radigue (drone music) Stress-osaka (1969) . A later work, L'Île Re-sonante (2000) . IMA Portrait documentary . The Analog Session (Alexander Robotnick & Ludus Pinsky): Fun-fare (2009) . N5 From Outer Space (2009) . Lettrobox1 . Misc: https://www.youtube.com/watch?v=8iIo5Y-oPhk https://www.youtube.com/watch?v=drbD4GigDAo https://www.youtube.com/watch?v=cjlnJciXbnY https://www.youtube.com/watch?v=5vkwtSRmDyI 70's: Tangerine Dream and Klaus Schulze Tangerine Dream: Zeit (1972) . Tangerine Dream, Rubycon (1975). Live at Conventry Cathedral (1975) . Klaus Schulze: Cyborg (1973) . Timewind (1975) . Moondown (1976) . Live 1977 . 70's: Vangelis \"Heaven and Hell\" (1975) . \"Pulstar\", Albedo 0.39 (1976) . Later famous works: Chariots of Fire (1981) . Blade Runner - Theme End Titles (1982) . 1492: Conquest of Paradise (1992) . 70's: Jean-Michel Jarre Oxygène (1976): Oxygène track 4 . Album cover . Oxygene: Live in Your Living Room (2007) . Equinoxe (1978) . Les champs magnétiques, 1981 . Interview, Oct. 2015 . 70's: Synth-Punk Suicide, Ghost Rider (1977) . The Normal: Warm Leatherette (1978) . Cover by Trent Reznor (NIN), Peter Murphy, Atticus Ross, Jeordie White, 2006 . T.V.O.D. (1978) . 70's: Kraftwerk Autobahn (1974) . Radioactivity (1975) . Radioactivity (Chernobyl version), Moscow (2005) . Radioactivity (Fukushima version), Tokyo - No Nukes 2012 . Radioactivity, French TV (1978) . Trans-Europe Express (1977) . Die Mensch-Maschine (1978) . \"The Robots\", The Man-Machine (1978) . The Robots (Roboter, original German version) . The Model (1978) . Computer World (1981): Computer Love . The Coldplay tribute to Kraftwerk, Talk (2005) . It's more fun to compute . 70's: Giorgio Moroder Donna Summer - I Feel Love (1977) . Cover with a modular synth . Chase, soundtrack of Midnight Express (Alan Parker, 1978) . Daft Punk tribute \"Giorgio by Moroder\", RAM (2014) . 70's: misc Pierre Henry, Machine Danse (1973). François de Roubaix, Le Monde électronique de François de Roubaix (1971-75). Isao Tomita: Snowflakes Are Dancing (Debussy) (1974) . Switched on rock - Electric Samurai (1972) . Pink Floyd, On the Run (1973, The Dark Side of the Moon ) . Close Encounters of the Third Kind (Steven Spielberg, 1977) . David Bowie and Brian Eno, Sense of Doubt (1977, Heroes ) . Brian Eno, Ambient 1: Music for Airports (1978). Tubeway Army, Are Friends Electric (1979) . A \"recent\" version (AllSaints Basement Sessions) . Edward Artemiev, Listening to Bach (From the movie \"Solaris\" 1972) . J.S. Bach - BWV 639 - Ich ruf' zu dir, Herr Jesu Christ . Bernard Parmegiani, De Natura Sonorum (1975). Throbbing Gristle, 20 Jazz Funk Greats (1979). 80's: the synth invasion (pop, techno, electro, new wave...) The synthesiser market skyrockets, prices fall. The year 1980 marks a turning point. Joy Division, Isolation (1980) . Orchestral Manoeuvres In The Dark, Statues (1980) . Orchestral Manoeuvres In The Dark, Enola Gay (1980) . Visage, Fade to Grey (1980) . Taxi Girl, Cherchez le garçon (1980) . Grauzone, Eisbaer (1980) . DAF, Alles Ist Gut . Depeche Mode, Just Can't Get Enough (1981) . Soft Cell, Tainted Love (1981) . In fact a cover of Gloria Jones (1964) . The Human League, Don't You Want Me (1981) . Kim Wilde, Cambodia (1981) . Liaisons Dangereuses, Los Niños del Parque (1981) . Guerre Froide, Demain Berlin (1981) . Yazoo, Don't Go (1982) . Tears for Fears, Mad World (1982) . Cover by Gary Jules (2001) . Gary Jules in 2023 . Front 242, Kampfbereit (1982) . The bass line is an homage to Kraftwerk's Kometenmelodie 2 ( Autobahn album, 1974) . New Order, Blue Monday (1983) . New Order, Confusion (1983) . Eurythmics, Sweet Dreams (Are Made Of This) (1983) . Frankie Goes To Hollywood, Relax (1983) . The Neon Judgement, The Fashion Party (1983) . Anne Clark, Our Darkness (1984) . Fad Gadget, Collapsing New People (1984) . Talk Talk, Such a Shame (1984) . Bronski Beat, Smalltown Boy (1984) . Alphaville, Forever Young (1984) . Harold Faltermeyer, Axel F (1984) Beverly Hills﻿ Cop Soundtrack . Art Of Noise, Moments In Love (1985) . Kraftwerk, Musique Non Stop (1986) . ... We can stop here, with Art of Noise (remember Luigi Russolo) and Musique Non Stop : electronic music is now mainstream! Developer Info Vincent Magnin","tags":"home","loc":"index.html"},{"title":"WAV_file – ForSynth ","text":"type, public, extends( tape_recorder ) :: WAV_file Inherits type~~wav_file~~InheritsGraph type~wav_file WAV_file type~tape_recorder tape_recorder type~wav_file->type~tape_recorder Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public :: duration Duration in seconds: character(len=:), public, allocatable :: filename integer, public :: fileunit real(kind=wp), public, dimension(:, :), allocatable :: left Two arrays stocking the stereo tracks: real(kind=wp), public, dimension(:, :), allocatable :: right Two arrays stocking the stereo tracks: integer, public :: samples Number of samples: integer, public :: tracks Number of audio tracks (excluding track 0 reserved for the final mix): Type-Bound Procedures procedure, public :: clear_tracks public  subroutine clear_tracks (self) Erase all tracks on all the channels of the tape. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self procedure, public :: close_WAV_file public  subroutine close_WAV_file (self) Must be called at the end. It normalizes the channels, writes them in the\nWAV file and closes it. It also deallocate the tape arrays. Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self procedure, public :: copy_section public  subroutine copy_section (self, from_track, to_track, t1, t2, t3) Copy section t1...t2 at t3, either on the same track or another one.\nThe content already present at t3 is overwritten.\nThe code suppose that t1 < t2 < t3. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: from_track integer, intent(in) :: to_track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: t3 procedure, public :: create_WAV_file public  subroutine create_WAV_file (self, filename, tracks, duration) Create a WAV file with a header: Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration procedure, public :: finalize public  subroutine finalize (self) Called by the close_WAV_file() method. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self procedure, public :: get_name public  function get_name (self) Returns the name of the WAV file: Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self Return Value character(len=len(self%filename)) procedure, public :: mix_tracks public  subroutine mix_tracks (self, levels, pan) Tracks 1 to tracks-1 are mixed on track 0. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: levels real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: pan procedure, public :: new public  subroutine new (self, tracks, duration) Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration procedure, private :: write_header public  subroutine write_header (self) Creates the 44 bytes WAV header and prints some information: Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self WAV parameters: Read more… procedure, private :: write_normalized_data public  subroutine write_normalized_data (self) This method normalizes the sound amplitude on track 0, before saving\nthe left and right channels in the WAV file. Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self Source Code type , extends ( tape_recorder ) :: WAV_file character ( len = :), allocatable :: filename integer :: fileunit contains procedure :: create_WAV_file procedure :: close_WAV_file procedure :: get_name procedure , private :: write_header procedure , private :: write_normalized_data end type WAV_file","tags":"","loc":"type/wav_file.html"},{"title":"tape_recorder – ForSynth ","text":"type, public :: tape_recorder Inherited by type~~tape_recorder~~InheritedByGraph type~tape_recorder tape_recorder type~wav_file WAV_file type~wav_file->type~tape_recorder Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), public :: duration Duration in seconds: real(kind=wp), public, dimension(:, :), allocatable :: left Two arrays stocking the stereo tracks: real(kind=wp), public, dimension(:, :), allocatable :: right Two arrays stocking the stereo tracks: integer, public :: samples Number of samples: integer, public :: tracks Number of audio tracks (excluding track 0 reserved for the final mix): Finalization Procedures final :: auto_finalize public  subroutine auto_finalize (self) An automatic finalizer, by security. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: self Type-Bound Procedures procedure, public :: clear_tracks public  subroutine clear_tracks (self) Erase all tracks on all the channels of the tape. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self procedure, public :: copy_section public  subroutine copy_section (self, from_track, to_track, t1, t2, t3) Copy section t1...t2 at t3, either on the same track or another one.\nThe content already present at t3 is overwritten.\nThe code suppose that t1 < t2 < t3. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: from_track integer, intent(in) :: to_track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: t3 procedure, public :: finalize public  subroutine finalize (self) Called by the close_WAV_file() method. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self procedure, public :: mix_tracks public  subroutine mix_tracks (self, levels, pan) Tracks 1 to tracks-1 are mixed on track 0. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: levels real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: pan procedure, public :: new public  subroutine new (self, tracks, duration) Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration Source Code type tape_recorder !> Number of audio tracks (excluding track 0 reserved for the final mix): integer :: tracks !> Duration in seconds: real ( wp ) :: duration !> Number of samples: integer :: samples !> Two arrays stocking the stereo tracks: real ( wp ), dimension (:, :), allocatable :: left , right contains procedure :: new procedure :: clear_tracks procedure :: mix_tracks procedure :: copy_section procedure :: finalize final :: auto_finalize end type tape_recorder","tags":"","loc":"type/tape_recorder.html"},{"title":"ADSR_envelope – ForSynth ","text":"type, public :: ADSR_envelope Components Type Visibility Attributes Name Initial real(kind=wp), public :: attack = 30.0_wp A   D S   R\n   /\\\n  /  ____\n /        \\\n/          \\\nhttps://en.wikipedia.org/wiki/Envelope_(music)\nDefault parameters of the ADSR envelope: real(kind=wp), public :: decay = 20.0_wp real(kind=wp), public :: release = 30.0_wp real(kind=wp), public :: sustain = 80.0_wp Type-Bound Procedures procedure, public :: get_level => ADSR_level private pure function ADSR_level (self, t, t1, t2) Returns the level in [0, 1] of the ADSR envelope at time t1 < t < t2 Arguments Type Intent Optional Attributes Name class( ADSR_envelope ), intent(in) :: self real(kind=wp), intent(in) :: t real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 Return Value real(kind=wp) procedure, public :: new => ADSR_new private  subroutine ADSR_new (self, A, D, S, R) Arguments Type Intent Optional Attributes Name class( ADSR_envelope ), intent(inout) :: self real(kind=wp), intent(in) :: A real(kind=wp), intent(in) :: D real(kind=wp), intent(in) :: S real(kind=wp), intent(in) :: R Source Code type ADSR_envelope !> A   D S   R !>    /\\ !>   /  \\____ !>  /        \\ !> /          \\ !> https://en.wikipedia.org/wiki/Envelope_(music) !> Default parameters of the ADSR envelope: real ( wp ) :: attack = 3 0.0_wp ! duration % real ( wp ) :: decay = 2 0.0_wp ! duration % real ( wp ) :: sustain = 8 0.0_wp ! max level % real ( wp ) :: release = 3 0.0_wp ! duration % contains procedure :: new => ADSR_new procedure :: get_level => ADSR_level end type ADSR_envelope","tags":"","loc":"type/adsr_envelope.html"},{"title":"add_misc_signal – ForSynth","text":"subroutine add_misc_signal(tape, track, t1, t2, f, Amp, choice) Add on the track a signal choosen by its number: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp integer, intent(in) :: choice Called by proc~~add_misc_signal~~CalledByGraph proc~add_misc_signal add_misc_signal program~misc_sounds misc_sounds program~misc_sounds->proc~add_misc_signal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_misc_signal ( tape , track , t1 , t2 , f , Amp , choice ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , choice real ( wp ), intent ( in ) :: t1 , t2 , f , Amp ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t real ( wp ), parameter :: phi = - 3 * PI ! Phase in radians at t=0 integer :: i , j omega = 2 * PI * f t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 select case ( choice ) case ( 0 ) ! Pure sinus tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) case ( 1 ) ! Science fiction signal... tape % left ( track , i ) = + Amp * sin ( omega * t + phi * cos ( 75 * t ) / ( 1 + log ( t / 100 + 0.01_wp ))) case ( 2 ) ! Hummmmmmmmmm... tape % left ( track , i ) = + Amp * sin ( omega * t + phi * sin ( omega * 0.2_wp * t )) case ( 3 ) ! UFO or siren? tape % left ( track , i ) = + Amp * sin ( omega * t + phi * cos ( 25 * t )) case ( 4 ) ! Noisy science fiction tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( t * 50 )) * t + phi ) case ( 5 ) ! Whistling, slower and slower... tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( sqrt ( t ) * 50 )) * t + phi ) case ( 6 ) ! Similar tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( log ( t ) * 50 )) * t + phi ) case ( 7 ) ! Dudududududu... tape % left ( track , i ) = + Amp * sin ( t * 30 ) * sin ( omega * t + phi ) case ( 8 ) ! Duuuuuuuuuuuuuuuuuuu tape % left ( track , i ) = + Amp * sin ( omega * t + phi * ( 0.5_wp + 0.5_wp * sin ( t * 500 ))) case ( 9 ) ! A higher duuuuuuuuuuuuuuuuuuu tape % left ( track , i ) = + Amp / 2 * sin ( omega * t + phi ) + Amp / 2 * sin ( omega * 1.1892_wp * t + phi ) case ( 10 ) ! Higher and higher... tape % left ( track , i ) = + Amp * sin (( omega * ( 1 + t / 10 )) * t + phi ) case ( 11 ) ! Dampening slowly do j = 1 , 7 tape % left ( track , i ) = + Amp / ( j * ( 1 + t ** j )) * sin ( j * omega * t ) end do case ( 12 ) ! Vibrato tape % left ( track , i ) = + Amp * sin ( omega * t + phi * ( 1._wp + 0.5_wp * sin ( 2 * PI * 4 * t ))) case ( 13 ) ! A mix tape % left ( track , i ) = + Amp * sin ( t ) * sin ( omega * t + phi ) & & + Amp * cos ( 2.5_wp * t ) * sin ( 1.5_wp * omega * t + phi ) + Amp * sin ( 3 * t ) * sin ( 2 * omega * t + phi ) case ( 14 ) ! Tremolo tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) + Amp * sin ( 1.001_wp * omega * t + phi ) & & + Amp * sin ( 0.999_wp * omega * t + phi ) case ( 15 ) ! Poke... (a short percussion based on the Sinc function) if ( omega * t + phi /= 0._wp ) then tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) / ( omega * t + phi ) else tape % left ( track , i ) = + Amp end if case ( 16 ) ! Science fiction, becoming higher and noisy tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.001_wp * sin ( t * 500 )) * t + phi ) case ( 17 ) ! Dissonant tape % left ( track , i ) = + Amp * sin ( omega * t + 4 * sin ( omega / 10 * t )) case ( 18 ) ! Dampening tape % left ( track , i ) = + Amp * ( 1 / ( 1 + t ** 3 )) * sin ( omega * t + 2 * sin ( omega * t + 3 * sin ( omega * t ))) case ( 19 ) ! Science-fiction, becoming higher and noisy tape % left ( track , i ) = + Amp * & & sin ( omega * ( 1._wp + 0.001_wp * sin ( t * 500 * ( 1._wp + 0.0002_wp * cos ( t * 50 )))) * t + phi ) case ( 20 ) ! Another dampening sound tape % left ( track , i ) = + Amp * ( exp ( - t ) * sin ( omega * t ) + 0.5_wp * exp ( - t ** 2 ) * sin ( 2 * omega * t ) & & + 0.25_wp * exp ( - t ** 3 ) * sin ( 3 * omega * t ) + 0.12_wp * exp ( - t ** 4 ) * sin ( 4 * omega * t )) case ( 21 ) ! Dampening slowly do j = 1 , 14 tape % left ( track , i ) = + Amp / ( j ** 2 * ( 1 + t ** j )) * sin ( j * omega * t ) end do case ( 22 ) ! Clarinet do j = 1 , 11 , + 2 tape % left ( track , i ) = + Amp / j ** 0.7_wp * sin ( j * omega * t ) end do case ( 23 ) ! Bessel function of the first kind J1: pong... tape % left ( track , i ) = + Amp * bessel_jn ( 1 , omega * t ) case ( 24 ) ! Bessel functions of the first kind: ping (far shorter) tape % left ( track , i ) = + Amp * bessel_jn ( 1 , omega * t ) * bessel_jn ( 2 , omega * t ) end select tape % right ( track , i ) = tape % left ( track , i ) t = t + dt end do end subroutine add_misc_signal","tags":"","loc":"proc/add_misc_signal.html"},{"title":"test_the_machine – ForSynth","text":"public  subroutine test_the_machine() A WAV file contains 64, 32 and 16 bits data or metadata,\nso we need those kinds. Arguments None","tags":"","loc":"proc/test_the_machine.html"},{"title":"weierstrass – ForSynth","text":"public pure function weierstrass(a, b, x) https://en.wikipedia.org/wiki/Weierstrass_function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~weierstrass~~CalledByGraph proc~weierstrass weierstrass proc~add_weierstrass add_weierstrass proc~add_weierstrass->proc~weierstrass program~all_signals all_signals program~all_signals->proc~add_weierstrass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/weierstrass.html"},{"title":"add_bell – ForSynth","text":"public  subroutine add_bell(tape, track, t1, f, Amp) Adds a Risset bell sound on the track at t1.\nJean-Claude Risset, An Introductory Catalogue Of Computer Synthesized Sounds,\nBell Telephone Laboratories  Murray Hill, New Jersey, 1969. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp Calls proc~~add_bell~~CallsGraph proc~add_bell add_bell proc~fit_exp fit_exp proc~add_bell->proc~fit_exp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_bell~~CalledByGraph proc~add_bell add_bell program~multiplication_bells multiplication_bells program~multiplication_bells->proc~add_bell Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_bell ( tape , track , t1 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , f , Amp real ( wp ) :: t , t2 real ( wp ) :: ratio , q real ( wp ) :: signal integer :: i ratio = f / 36 8._wp ! [Risset, 1969] gives a bell with a 368 Hz fundamental. t2 = t1 + 2 0._wp ! The longest partial (hum) is lasting 20 seconds. ! The MIN() is used to stay inside the tape arrays. do concurrent ( i = nint ( t1 * RATE ) : MIN ( nint ( t2 * RATE ) - 1 , tape % samples )) t = t1 + ( i - nint ( t1 * RATE )) * dt q = ( 2 * PI * ratio ) * ( t - t1 ) ! The eleven frequencies come from [Risset, 1969], sound #430. ! x1 and x2 are the start and end of an exponentially decaying envelope ! and y1 and y2 are its height at x1 and x2. signal = Amp * ( & ! Hum (with beating between 224 Hz and 225 Hz): & fit_exp ( t , x1 = t1 + 0._wp , y1 = 1.5_wp , x2 = t1 + 2 0._wp , y2 = 0.001_wp ) * sin ( q * 22 4.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 1._wp , x2 = t1 + 1 8._wp , y2 = 0.001_wp ) * sin ( q * 22 5.0_wp ) & ! Fundamental (with beating between 368 Hz and 369.7 Hz): & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 1.5_wp , x2 = t1 + 1 3._wp , y2 = 0.001_wp ) * sin ( q * 36 8.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2.7_wp , x2 = t1 + 1 1._wp , y2 = 0.001_wp ) * sin ( q * 36 9.7_wp ) & ! Other partials: & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 4._wp , x2 = t1 + 6.5_wp , y2 = 0.001_wp ) * sin ( q * 47 6.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2.5_wp , x2 = t1 + 7._wp , y2 = 0.001_wp ) * sin ( q * 68 0.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2.2_wp , x2 = t1 + 5._wp , y2 = 0.001_wp ) * sin ( q * 80 0.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2._wp , x2 = t1 + 4._wp , y2 = 0.001_wp ) * sin ( q * 109 6._wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2._wp , x2 = t1 + 3._wp , y2 = 0.001_wp ) * sin ( q * 120 0._wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 1.5_wp , x2 = t1 + 2._wp , y2 = 0.001_wp ) * sin ( q * 150 4._wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2._wp , x2 = t1 + 1.5_wp , y2 = 0.001_wp ) * sin ( q * 162 8._wp ) ) tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_bell","tags":"","loc":"proc/add_bell.html"},{"title":"add_karplus_strong – ForSynth","text":"public  subroutine add_karplus_strong(tape, track, t1, t2, f, Amp) Karplus and Strong algorithm (1983), for plucked-string\nhttp://crypto.stanford.edu/~blynn/sound/karplusstrong.html\nhttps://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp Called by proc~~add_karplus_strong~~CalledByGraph proc~add_karplus_strong add_karplus_strong proc~add_broken_chord add_broken_chord proc~add_broken_chord->proc~add_karplus_strong program~all_signals all_signals program~all_signals->proc~add_karplus_strong program~arpeggios arpeggios program~arpeggios->proc~add_karplus_strong program~arpeggios->proc~add_broken_chord program~blues blues program~blues->proc~add_karplus_strong program~chords_and_melody chords_and_melody program~chords_and_melody->proc~add_karplus_strong Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_karplus_strong ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp real ( wp ) :: signal , r integer :: i , P integer :: i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 P = nint ( RATE / f ) - 2 ! Initial noise: do i = i1 , i1 + P ! 0 <= r < 1 call random_number ( r ) ! -Amp <= signal < +Amp signal = Amp * ( 2.0_wp * r - 1.0_wp ) ! Track 0 is used as an auxiliary track: tape % left ( 0 , i ) = signal tape % right ( 0 , i ) = signal end do ! Delay and decay: do i = i1 + P + 1 , i2 tape % left ( 0 , i ) = ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) / 2.0_wp tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong","tags":"","loc":"proc/add_karplus_strong.html"},{"title":"add_karplus_strong_drum – ForSynth","text":"public  subroutine add_karplus_strong_drum(tape, track, t1, t2, P, Amp) Karplus and Strong (1983) algorithm for obtaining a percussion sound.\nTypically, P is taken to be between 150 and 1000.\nCaution: this algorithm overwrites what may have existed on the\ntrack at the chosen location.\nYou may also want to modify the b parameter to make some weird sounds,\nsomewhere between percussion and guitar...\nhttp://crypto.stanford.edu/~blynn/sound/karplusstrong.html\nhttps://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 integer, intent(in) :: P real(kind=wp), intent(in) :: Amp Called by proc~~add_karplus_strong_drum~~CalledByGraph proc~add_karplus_strong_drum add_karplus_strong_drum program~drum_machine drum_machine program~drum_machine->proc~add_karplus_strong_drum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_karplus_strong_drum ( tape , track , t1 , t2 , P , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , P real ( wp ), intent ( in ) :: t1 , t2 , Amp integer :: i1 , i2 real ( wp ) :: r integer :: i ! 0 <= b <= 1 but b = 0.5 is the best value for good drums: real ( wp ), parameter :: b = 0.5_wp real ( wp ) :: the_sign i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 ! Track 0 is used as an auxiliary track. ! Attack: tape % left ( 0 , i1 : i1 + P ) = Amp tape % right ( 0 , i1 : i1 + P ) = Amp ! Evolution and decay: do i = i1 + P + 1 , i2 ! The sign of the sample is random: call random_number ( r ) if ( r < b ) then the_sign = + 1._wp else the_sign = - 1._wp end if ! Mean of samples i-P and i-P-1: tape % left ( 0 , i ) = the_sign * 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong_drum","tags":"","loc":"proc/add_karplus_strong_drum.html"},{"title":"add_karplus_strong_drum_stretched – ForSynth","text":"public  subroutine add_karplus_strong_drum_stretched(tape, track, t1, t2, P, Amp) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 integer, intent(in) :: P real(kind=wp), intent(in) :: Amp Called by proc~~add_karplus_strong_drum_stretched~~CalledByGraph proc~add_karplus_strong_drum_stretched add_karplus_strong_drum_stretched program~drum_machine drum_machine program~drum_machine->proc~add_karplus_strong_drum_stretched Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_karplus_strong_drum_stretched ( tape , track , t1 , t2 , P , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , P real ( wp ), intent ( in ) :: t1 , t2 , Amp integer :: i1 , i2 real ( wp ) :: r integer :: i ! 0 <= b <= 1 but b = 0.5 is the best value for good drums: real ( wp ), parameter :: b = 0.5_wp ! Stretch factor S > 1: real ( wp ), parameter :: S = 4._wp i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 ! Track 0 is used as an auxiliary track. ! Attack: tape % left ( 0 , i1 : i1 + P ) = Amp tape % right ( 0 , i1 : i1 + P ) = Amp ! Evolution and decay: do i = i1 + P + 1 , i2 ! The sign of the sample is random: call random_number ( r ) if ( r < b ) then call random_number ( r ) if ( r < 1 / S ) then tape % left ( 0 , i ) = + 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) else tape % left ( 0 , i ) = + tape % left ( 0 , i - P ) end if else call random_number ( r ) if ( r < 1 / S ) then tape % left ( 0 , i ) = - 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) else tape % left ( 0 , i ) = - tape % left ( 0 , i - P ) end if end if tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong_drum_stretched","tags":"","loc":"proc/add_karplus_strong_drum_stretched.html"},{"title":"add_karplus_strong_stretched – ForSynth","text":"public  subroutine add_karplus_strong_stretched(tape, track, t1, t2, f, Amp) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp Called by proc~~add_karplus_strong_stretched~~CalledByGraph proc~add_karplus_strong_stretched add_karplus_strong_stretched program~all_signals all_signals program~all_signals->proc~add_karplus_strong_stretched Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_karplus_strong_stretched ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp integer :: i1 , i2 real ( wp ) :: r integer :: i integer :: P ! Stretch factor S > 1: real ( wp ), parameter :: S = 4._wp i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 P = nint ( RATE / f ) - 2 ! Initial noise: do i = i1 , i1 + P ! 0 <= r < 1 call random_number ( r ) ! Track 0 is used as an auxiliary track: tape % left ( 0 , i ) = Amp * ( 2.0_wp * r - 1.0_wp ) tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Delay and decay: do i = i1 + P + 1 , i2 call random_number ( r ) if ( r < 1 / S ) then tape % left ( 0 , i ) = + 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) else tape % left ( 0 , i ) = + tape % left ( 0 , i - P ) end if tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong_stretched","tags":"","loc":"proc/add_karplus_strong_stretched.html"},{"title":"add_noise – ForSynth","text":"public  subroutine add_noise(tape, track, t1, t2, Amp, envelope) Add white noise on the track: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope Calls proc~~add_noise~~CallsGraph proc~add_noise add_noise proc~adsr_level ADSR_envelope%ADSR_level proc~add_noise->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_noise~~CalledByGraph proc~add_noise add_noise program~all_signals all_signals program~all_signals->proc~add_noise Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_noise.html"},{"title":"add_sawtooth_wave – ForSynth","text":"public  subroutine add_sawtooth_wave(tape, track, t1, t2, f, Amp, envelope) Adds on the track a sawtooth wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope Calls proc~~add_sawtooth_wave~~CallsGraph proc~add_sawtooth_wave add_sawtooth_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_sawtooth_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_sawtooth_wave~~CalledByGraph proc~add_sawtooth_wave add_sawtooth_wave program~all_signals all_signals program~all_signals->proc~add_sawtooth_wave Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_sawtooth_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Period in seconds: real ( wp ) :: tau ! Time in seconds: real ( wp ) :: t real ( wp ) :: signal ! ADSR Envelope value: real ( wp ) :: env integer :: i env = 1._wp ! Default value if no envelope is passed tau = 1.0_wp / f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) ! We substract 0.5 for the signal to be centered on 0: signal = 2 * ((( t / tau ) - floor ( t / tau )) - 0.5_wp ) * Amp * env tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_sawtooth_wave","tags":"","loc":"proc/add_sawtooth_wave.html"},{"title":"add_sine_wave – ForSynth","text":"public  subroutine add_sine_wave(tape, track, t1, t2, f, Amp, envelope) Adds on the track a sine wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope Calls proc~~add_sine_wave~~CallsGraph proc~add_sine_wave add_sine_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_sine_wave~~CalledByGraph proc~add_sine_wave add_sine_wave proc~add_morse_code add_morse_code proc~add_morse_code->proc~add_sine_wave proc~add_note add_note proc~add_note->proc~add_sine_wave program~all_signals all_signals program~all_signals->proc~add_sine_wave proc~add_chord add_chord proc~add_chord->proc~add_note program~radioactivity radioactivity program~radioactivity->proc~add_morse_code program~radioactivity->proc~add_chord program~chords_and_melody chords_and_melody program~chords_and_melody->proc~add_chord program~demo_effects demo_effects program~demo_effects->proc~add_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_sine_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Phase at t=0 s, radians: real ( wp ), parameter :: phi = 0.0_wp ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: signal integer :: i env = 1._wp ! Default value if no envelope is passed omega = 2.0_wp * PI * f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) signal = Amp * sin ( omega * t + phi ) * env tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_sine_wave","tags":"","loc":"proc/add_sine_wave.html"},{"title":"add_square_wave – ForSynth","text":"public  subroutine add_square_wave(tape, track, t1, t2, f, Amp, envelope) Adds on the track a square wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope Calls proc~~add_square_wave~~CallsGraph proc~add_square_wave add_square_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_square_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_square_wave~~CalledByGraph proc~add_square_wave add_square_wave program~all_signals all_signals program~all_signals->proc~add_square_wave Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_square_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Period in seconds: real ( wp ) :: tau ! Time in seconds: real ( wp ) :: t real ( wp ) :: signal ! ADSR Envelope value: real ( wp ) :: env integer :: i , n env = 1._wp ! Default value if no envelope is passed tau = 1.0_wp / f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) ! Number of the half-period: n = int ( t / ( tau / 2.0_wp )) ! If n is even, signal is +Amp, if odd -Amp: if ( mod ( n , 2 ) == 0 ) then signal = + Amp * env else signal = - Amp * env end if tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_square_wave","tags":"","loc":"proc/add_square_wave.html"},{"title":"add_triangle_wave – ForSynth","text":"public  subroutine add_triangle_wave(tape, track, t1, t2, f, Amp, envelope) Adds on the track a triangle wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope Calls proc~~add_triangle_wave~~CallsGraph proc~add_triangle_wave add_triangle_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_triangle_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_triangle_wave~~CalledByGraph proc~add_triangle_wave add_triangle_wave program~all_signals all_signals program~all_signals->proc~add_triangle_wave Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_triangle_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Period in seconds: real ( wp ) :: tau ! Time in seconds: real ( wp ) :: t real ( wp ) :: signal ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: a , x integer :: i , n env = 1._wp ! Default value if no envelope is passed tau = 1.0_wp / f a = ( 2.0_wp * Amp ) / ( tau / 2.0_wp ) do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) ! Number of the half-period: n = int ( t / ( tau / 2.0_wp )) ! Is n even or odd ? if ( mod ( n , 2 ) == 0 ) then x = t - n * ( tau / 2.0_wp ) ; signal = a * x - Amp else x = t - n * ( tau / 2.0_wp ) + tau / 2.0_wp ; signal = - a * x + 3.0_wp * Amp end if tape % left ( track , i ) = tape % left ( track , i ) + signal * env tape % right ( track , i ) = tape % right ( track , i ) + signal * env end do end subroutine add_triangle_wave","tags":"","loc":"proc/add_triangle_wave.html"},{"title":"add_weierstrass – ForSynth","text":"public  subroutine add_weierstrass(tape, track, t1, t2, f, Amp, envelope) Add a fractal signal on the track with an envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope Calls proc~~add_weierstrass~~CallsGraph proc~add_weierstrass add_weierstrass proc~adsr_level ADSR_envelope%ADSR_level proc~add_weierstrass->proc~adsr_level proc~weierstrass weierstrass proc~add_weierstrass->proc~weierstrass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_weierstrass~~CalledByGraph proc~add_weierstrass add_weierstrass program~all_signals all_signals program~all_signals->proc~add_weierstrass Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_weierstrass ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t ! Phase at t=0 s, radians: real ( wp ), parameter :: phi = 0.0_wp ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: signal real ( wp ) :: a , b integer :: i ! 0 < a < 1. a = 0.975_wp ! If a.b > 1 the function is fractal: b = 1._wp / . 975_wp + 0.005_wp ; env = 1._wp ! Default value if no envelope is passed omega = 2.0_wp * PI * f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) signal = Amp * weierstrass ( a , b , omega * t + phi ) * env ! It is addd to the already present signal: tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_weierstrass","tags":"","loc":"proc/add_weierstrass.html"},{"title":"fr – ForSynth","text":"public  function fr(note) Returns the frequency of the note.\nThe note name is composed of two or three characters,\nfor example \"A4\", \"A#4\", \"Ab4\", where the final character is\nthe octave. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: note Return Value real(kind=wp) Called by proc~~fr~~CalledByGraph proc~fr fr program~all_signals all_signals program~all_signals->proc~fr program~arpeggios arpeggios program~arpeggios->proc~fr program~blues blues program~blues->proc~fr program~chords_and_melody chords_and_melody program~chords_and_melody->proc~fr program~demo_effects demo_effects program~demo_effects->proc~fr program~misc_sounds misc_sounds program~misc_sounds->proc~fr program~radioactivity radioactivity program~radioactivity->proc~fr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( wp ) function fr ( note ) character ( * ), intent ( in ) :: note ! 0 <= octave <=9 integer :: octave ! Gap relative to PITCH, in semitones: integer :: gap ! ASCII code of the 0 character: integer , parameter :: zero = iachar ( '0' ) select case ( note ( 1 : 1 )) case ( 'C' ) gap = - 9 case ( 'D' ) gap = - 7 case ( 'E' ) gap = - 5 case ( 'F' ) gap = - 4 case ( 'G' ) gap = - 2 case ( 'A' ) gap = 0 case ( 'B' ) gap = + 2 case default print * , \"ERROR! Note name unknown...\" stop end select ! Treating accidentals (sharp, flat) and computing the octave: select case ( note ( 2 : 2 )) case ( 'b' ) gap = gap - 1 octave = iachar ( note ( 3 : 3 )) - zero case ( '#' ) gap = gap + 1 octave = iachar ( note ( 3 : 3 )) - zero case default octave = iachar ( note ( 2 : 2 )) - zero end select if (( octave >= 0 ) . and . ( octave <= 9 )) then gap = gap + ( octave - 4 ) * 12 else print * , \"ERROR! Octave out of bounds [0; 9]\" stop end if ! Computing the frequency of the note: fr = PITCH * SEMITONE ** ( real ( gap , wp )) end function fr","tags":"","loc":"proc/fr.html"},{"title":"add_broken_chord – ForSynth","text":"public  subroutine add_broken_chord(tape, track, t1, t2, f, Amp, chord) Writes a broken chord using an array containing the intervals\n(see the music_common module). It uses plucked strings (Karplus-Strong).\nFor the moment, each note has the same duration.\nhttps://en.wikipedia.org/wiki/Arpeggio Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp integer, intent(in), dimension(:) :: chord Calls proc~~add_broken_chord~~CallsGraph proc~add_broken_chord add_broken_chord proc~add_karplus_strong add_karplus_strong proc~add_broken_chord->proc~add_karplus_strong Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_broken_chord~~CalledByGraph proc~add_broken_chord add_broken_chord program~arpeggios arpeggios program~arpeggios->proc~add_broken_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_broken_chord ( tape , track , t1 , t2 , f , Amp , chord ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp integer , dimension (:), intent ( in ) :: chord integer :: i , interval real ( wp ) :: dnote ! duration of each note of the chord real ( wp ) :: fnote real ( wp ) :: t dnote = ( t2 - t1 ) / size ( chord ) t = t1 do i = 1 , size ( chord ) interval = chord ( i ) fnote = f * SEMITONE ** interval call add_karplus_strong ( tape , track , t1 = t , t2 = t + dnote , f = fnote , Amp = Amp ) t = t + dnote end do end subroutine add_broken_chord","tags":"","loc":"proc/add_broken_chord.html"},{"title":"add_chord – ForSynth","text":"public  subroutine add_chord(tape, track, t1, t2, f, Amp, chord, envelope) Writes a chord using an array containing the intervals\n(see the music_common module) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp integer, intent(in), dimension(:) :: chord type( ADSR_envelope ), intent(inout), optional :: envelope Calls proc~~add_chord~~CallsGraph proc~add_chord add_chord proc~add_note add_note proc~add_chord->proc~add_note proc~add_sine_wave add_sine_wave proc~add_note->proc~add_sine_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_chord~~CalledByGraph proc~add_chord add_chord program~chords_and_melody chords_and_melody program~chords_and_melody->proc~add_chord program~demo_effects demo_effects program~demo_effects->proc~add_chord program~radioactivity radioactivity program~radioactivity->proc~add_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_chord ( tape , track , t1 , t2 , f , Amp , chord , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp integer , dimension (:), intent ( in ) :: chord type ( ADSR_envelope ), optional , intent ( inout ) :: envelope integer :: i , interval do i = 1 , size ( chord ) interval = chord ( i ) call add_note ( tape , track , t1 , t2 , f * SEMITONE ** interval , Amp , envelope ) end do end subroutine add_chord","tags":"","loc":"proc/add_chord.html"},{"title":"add_note – ForSynth","text":"public  subroutine add_note(tape, track, t1, t2, f, Amp, envelope) A note of fundamental frequency f with harmonics, based on sine waves.\nhttps://en.wikipedia.org/wiki/Harmonic Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(inout), optional :: envelope Calls proc~~add_note~~CallsGraph proc~add_note add_note proc~add_sine_wave add_sine_wave proc~add_note->proc~add_sine_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_note~~CalledByGraph proc~add_note add_note proc~add_chord add_chord proc~add_chord->proc~add_note program~chords_and_melody chords_and_melody program~chords_and_melody->proc~add_chord program~demo_effects demo_effects program~demo_effects->proc~add_chord program~radioactivity radioactivity program~radioactivity->proc~add_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_note.html"},{"title":"apply_autopan_effect – ForSynth","text":"public  subroutine apply_autopan_effect(tape, track, t1, t2, f, AmpLFO) Make the sound move from one channel to the other one at a frequency f\nand with an amplitude AmpLFO in [0 ; 1]. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: AmpLFO Called by proc~~apply_autopan_effect~~CalledByGraph proc~apply_autopan_effect apply_autopan_effect program~demo_effects demo_effects program~demo_effects->proc~apply_autopan_effect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/apply_autopan_effect.html"},{"title":"apply_delay_effect – ForSynth","text":"public  subroutine apply_delay_effect(tape, track, t1, t2, delay, Amp) Add the sound from \"delay\" seconds before,\nand multiply by Amp<1 for dampening. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: delay real(kind=wp), intent(in) :: Amp Called by proc~~apply_delay_effect~~CalledByGraph proc~apply_delay_effect apply_delay_effect program~chords_and_melody chords_and_melody program~chords_and_melody->proc~apply_delay_effect program~demo_effects demo_effects program~demo_effects->proc~apply_delay_effect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/apply_delay_effect.html"},{"title":"apply_fuzz_effect – ForSynth","text":"public  subroutine apply_fuzz_effect(tape, track, t1, t2, level) Apply distorsion with hard clipping\nhttps://en.wikipedia.org/wiki/Distortion_(music) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: level Called by proc~~apply_fuzz_effect~~CalledByGraph proc~apply_fuzz_effect apply_fuzz_effect program~demo_effects demo_effects program~demo_effects->proc~apply_fuzz_effect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/apply_fuzz_effect.html"},{"title":"apply_reverse_effect – ForSynth","text":"public  subroutine apply_reverse_effect(tape, track, t1, t2) Copy the samples at the same t1 but in reverse order: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 Called by proc~~apply_reverse_effect~~CalledByGraph proc~apply_reverse_effect apply_reverse_effect program~shepard_scale shepard_scale program~shepard_scale->proc~apply_reverse_effect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/apply_reverse_effect.html"},{"title":"apply_tremolo_effect – ForSynth","text":"public  subroutine apply_tremolo_effect(tape, track, t1, t2, f, AmpLFO) A sinusoidal modulation of the amplitude of a signal (tremolo) :\nf : tremolo frequency (typically a few Hz)\nAmpLFO : tremolo amplitude in [0 ; 1]\nhttps://en.wikipedia.org/wiki/Vibrato#Vibrato_and_tremolo/ Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: AmpLFO Called by proc~~apply_tremolo_effect~~CalledByGraph proc~apply_tremolo_effect apply_tremolo_effect program~blues blues program~blues->proc~apply_tremolo_effect program~demo_effects demo_effects program~demo_effects->proc~apply_tremolo_effect Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/apply_tremolo_effect.html"},{"title":"get_name – ForSynth","text":"public  function get_name(self) Returns the name of the WAV file: Type Bound WAV_file Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self Return Value character(len=len(self%filename)) Called by proc~~get_name~~CalledByGraph proc~get_name WAV_file%get_name program~all_signals all_signals program~all_signals->proc~get_name program~arpeggios arpeggios program~arpeggios->proc~get_name program~blues blues program~blues->proc~get_name program~chords_and_melody chords_and_melody program~chords_and_melody->proc~get_name program~demo_effects demo_effects program~demo_effects->proc~get_name program~doppler_effect doppler_effect program~doppler_effect->proc~get_name program~drone_music drone_music program~drone_music->proc~get_name program~drum_machine drum_machine program~drum_machine->proc~get_name program~misc_sounds misc_sounds program~misc_sounds->proc~get_name program~multiplication_bells multiplication_bells program~multiplication_bells->proc~get_name program~radioactivity radioactivity program~radioactivity->proc~get_name program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~get_name program~shepard_scale shepard_scale program~shepard_scale->proc~get_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/get_name.html"},{"title":"close_WAV_file – ForSynth","text":"public  subroutine close_WAV_file(self) Must be called at the end. It normalizes the channels, writes them in the\nWAV file and closes it. It also deallocate the tape arrays. Type Bound WAV_file Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self Calls proc~~close_wav_file~~CallsGraph proc~close_wav_file WAV_file%close_WAV_file proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~close_wav_file~~CalledByGraph proc~close_wav_file WAV_file%close_WAV_file program~all_signals all_signals program~all_signals->proc~close_wav_file program~arpeggios arpeggios program~arpeggios->proc~close_wav_file program~blues blues program~blues->proc~close_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~close_wav_file program~demo_effects demo_effects program~demo_effects->proc~close_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~close_wav_file program~drone_music drone_music program~drone_music->proc~close_wav_file program~drum_machine drum_machine program~drum_machine->proc~close_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~close_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~close_wav_file program~radioactivity radioactivity program~radioactivity->proc~close_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~close_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~close_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/close_wav_file.html"},{"title":"create_WAV_file – ForSynth","text":"public  subroutine create_WAV_file(self, filename, tracks, duration) Create a WAV file with a header: Type Bound WAV_file Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration Calls proc~~create_wav_file~~CallsGraph proc~create_wav_file WAV_file%create_WAV_file proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~create_wav_file~~CalledByGraph proc~create_wav_file WAV_file%create_WAV_file program~all_signals all_signals program~all_signals->proc~create_wav_file program~arpeggios arpeggios program~arpeggios->proc~create_wav_file program~blues blues program~blues->proc~create_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~create_wav_file program~demo_effects demo_effects program~demo_effects->proc~create_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~create_wav_file program~drone_music drone_music program~drone_music->proc~create_wav_file program~drum_machine drum_machine program~drum_machine->proc~create_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~create_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~create_wav_file program~radioactivity radioactivity program~radioactivity->proc~create_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~create_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~create_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine create_WAV_file ( self , filename , tracks , duration ) class ( WAV_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer , intent ( in ) :: tracks real ( wp ), intent ( in ) :: duration call self % new ( tracks , duration ) self % filename = filename open ( newunit = self % fileunit , file = self % filename , access = 'stream' , status = 'replace' , action = 'write' ) call self % write_header () end subroutine create_WAV_file","tags":"","loc":"proc/create_wav_file.html"},{"title":"write_header – ForSynth","text":"public  subroutine write_header(self) Creates the 44 bytes WAV header and prints some information: Type Bound WAV_file Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self WAV parameters: Number of channels: 1 for mono, 2 for stereo, etc. Called by proc~~write_header~~CalledByGraph proc~write_header WAV_file%write_header proc~create_wav_file WAV_file%create_WAV_file proc~create_wav_file->proc~write_header program~all_signals all_signals program~all_signals->proc~create_wav_file program~arpeggios arpeggios program~arpeggios->proc~create_wav_file program~blues blues program~blues->proc~create_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~create_wav_file program~demo_effects demo_effects program~demo_effects->proc~create_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~create_wav_file program~drone_music drone_music program~drone_music->proc~create_wav_file program~drum_machine drum_machine program~drum_machine->proc~create_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~create_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~create_wav_file program~radioactivity radioactivity program~radioactivity->proc~create_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~create_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~create_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_header ( self ) class ( WAV_file ), intent ( inout ) :: self !**************** ! WAV parameters: !**************** ! Number of channels: 1 for mono, 2 for stereo, etc. integer ( INT16 ), parameter :: CHANNELS = 2 integer ( INT16 ), parameter :: BITS_PER_SAMPLE = 16 integer ( INT64 ) :: DATA_BYTES integer ( INT32 ) :: file_size , bytes_per_second , data_size integer ( INT16 ) :: bytes_per_sample print * , \"Nb of tracks, excluding track 0:\" , self % tracks DATA_BYTES = ( BITS_PER_SAMPLE / 8 ) * CHANNELS * self % samples print * , \"Used RAM:   \" , DATA_BYTES * self % tracks , \"bytes\" print * , \"File size ~ \" , DATA_BYTES , \"bytes\" associate ( u => self % fileunit ) ! RIFF format: write ( u , iostat = status ) \"RIFF\" ! Remaining bytes after this data: file_size = 36 + DATA_BYTES write ( u , iostat = status ) file_size write ( u , iostat = status ) \"WAVE\" ! ***** First sub-chunk ***** ! Don't remove the final space in the string! write ( u , iostat = status ) \"fmt \" ! Remaining bytes in this sub-chunk, 16 for PCM (32 bits integer): write ( u , iostat = status ) 16_INT32 ! Encoding is 1 for PCM (16 bits integer): write ( u , iostat = status ) 1_INT16 write ( u , iostat = status ) int ( CHANNELS , kind = INT16 ) ! Sampling frequency: write ( u , iostat = status ) int ( RATE , kind = INT32 ) bytes_per_second = RATE * CHANNELS * ( BITS_PER_SAMPLE / 8 ) write ( u , iostat = status ) bytes_per_second bytes_per_sample = CHANNELS * ( BITS_PER_SAMPLE / 8 ) write ( u , iostat = status ) bytes_per_sample write ( u , iostat = status ) BITS_PER_SAMPLE ! ***** Second sub-chunk ***** write ( u , iostat = status ) \"data\" data_size = self % samples * CHANNELS * ( BITS_PER_SAMPLE / 8 ) write ( u , iostat = status ) data_size end associate end subroutine write_header","tags":"","loc":"proc/write_header.html"},{"title":"write_normalized_data – ForSynth","text":"public  subroutine write_normalized_data(self) This method normalizes the sound amplitude on track 0, before saving\nthe left and right channels in the WAV file. Type Bound WAV_file Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self Called by proc~~write_normalized_data~~CalledByGraph proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file WAV_file%close_WAV_file proc~close_wav_file->proc~write_normalized_data program~all_signals all_signals program~all_signals->proc~close_wav_file program~arpeggios arpeggios program~arpeggios->proc~close_wav_file program~blues blues program~blues->proc~close_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~close_wav_file program~demo_effects demo_effects program~demo_effects->proc~close_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~close_wav_file program~drone_music drone_music program~drone_music->proc~close_wav_file program~drum_machine drum_machine program~drum_machine->proc~close_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~close_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~close_wav_file program~radioactivity radioactivity program~radioactivity->proc~close_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~close_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~close_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/write_normalized_data.html"},{"title":"the_solution – ForSynth","text":"function the_solution(a, b, c, tobs) We solve the Quadratic equation,\nbut physically one and only one solution can exist:\nwe know the sound was emitted before we hear it!> Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: tobs Return Value real(kind=wp) Called by proc~~the_solution~~CalledByGraph proc~the_solution the_solution program~doppler_effect doppler_effect program~doppler_effect->proc~the_solution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/the_solution.html"},{"title":"string_to_morse – ForSynth","text":"public  function string_to_morse(string) result(morse) This function receives a string and returns its Morse code translation.\nThe input string can contain only alphabetic characters in upper or lower case,\ndigits 0..9 and spaces. All other characters will be considered as spaces.\nCharacters inside words are separated by one space, and words by two spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Called by proc~~string_to_morse~~CalledByGraph proc~string_to_morse string_to_morse program~radioactivity radioactivity program~radioactivity->proc~string_to_morse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function string_to_morse ( string ) result ( morse ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: morse character ( len = 1 ) :: c integer :: i , k morse = \"\" do i = 1 , len_trim ( string ) c = string ( i : i ) select case ( c ) case ( 'A' : 'Z' ) k = iachar ( c ) - iachar ( 'A' ) + 1 case ( 'a' : 'z' ) k = iachar ( c ) - iachar ( 'a' ) + 1 case ( '0' : '9' ) k = iachar ( c ) - iachar ( '0' ) + 27 case default k = 0 ! A space end select if ( k /= 0 ) then morse = morse // trim ( morse_table ( k )) // ' ' else morse = morse // ' ' end if end do morse = trim ( morse ) end function string_to_morse","tags":"","loc":"proc/string_to_morse.html"},{"title":"add_morse_code – ForSynth","text":"public  subroutine add_morse_code(tape, track, t1, f, Amp, string) Adds on the specified track a Morse code translation of the string, starting at\ntime t1. The frequency f must correspond to a high tone, for example 880 Hz. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp character(len=*), intent(in) :: string Calls proc~~add_morse_code~~CallsGraph proc~add_morse_code add_morse_code proc~add_sine_wave add_sine_wave proc~add_morse_code->proc~add_sine_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_morse_code~~CalledByGraph proc~add_morse_code add_morse_code program~radioactivity radioactivity program~radioactivity->proc~add_morse_code Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_morse_code ( tape , track , t1 , f , Amp , string ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , f , Amp character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: c real ( wp ) :: t ! Time in seconds real ( wp ) :: dot = 0.050_wp ! The fundamental duration in seconds integer :: i t = t1 do i = 1 , len_trim ( string ) c = string ( i : i ) select case ( c ) case ( '.' ) call add_sine_wave ( tape , track , t , t + 1 * dot , f , Amp ) t = t + 1 * dot case ( '-' ) ! A dash last three times longer than a dot call add_sine_wave ( tape , track , t , t + 3 * dot , f , Amp ) t = t + 3 * dot case ( ' ' ) t = t + ( 3 - 1 ) * dot ! Silence between letters of a word, ! taking into account the silence added after END SELECT ! A double space means we are between two words, and the ! total silence must last 7 dots: if ( string ( i + 1 : i + 1 ) == ' ' ) then t = t + 4 * dot end if end select t = t + dot ! A silence between dots and dashes in a character end do end subroutine add_morse_code","tags":"","loc":"proc/add_morse_code.html"},{"title":"add_geiger_ping – ForSynth","text":"subroutine add_geiger_ping(tape, track, t1, t2, f, Amp) Adds the signal of a radioactive decay heard with a Geiger counter. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp Called by proc~~add_geiger_ping~~CalledByGraph proc~add_geiger_ping add_geiger_ping program~radioactivity radioactivity program~radioactivity->proc~add_geiger_ping Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_geiger_ping ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp real ( wp ) :: b ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t integer :: i omega = 2 * PI * f t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 ! Bessel functions of the first kind: a short ping b = Amp * bessel_jn ( 1 , omega * t ) * bessel_jn ( 2 , omega * t ) tape % left ( track , i ) = tape % left ( track , i ) + b tape % right ( track , i ) = tape % right ( track , i ) + b t = t + dt end do end subroutine add_geiger_ping","tags":"","loc":"proc/add_geiger_ping.html"},{"title":"auto_finalize – ForSynth","text":"public  subroutine auto_finalize(self) An automatic finalizer, by security. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: self","tags":"","loc":"proc/auto_finalize.html"},{"title":"clear_tracks – ForSynth","text":"public  subroutine clear_tracks(self) Erase all tracks on all the channels of the tape. Type Bound tape_recorder Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self Called by proc~~clear_tracks~~CalledByGraph proc~clear_tracks tape_recorder%clear_tracks proc~new tape_recorder%new proc~new->proc~clear_tracks proc~create_wav_file WAV_file%create_WAV_file proc~create_wav_file->proc~new program~all_signals all_signals program~all_signals->proc~create_wav_file program~arpeggios arpeggios program~arpeggios->proc~create_wav_file program~blues blues program~blues->proc~create_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~create_wav_file program~demo_effects demo_effects program~demo_effects->proc~create_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~create_wav_file program~drone_music drone_music program~drone_music->proc~create_wav_file program~drum_machine drum_machine program~drum_machine->proc~create_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~create_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~create_wav_file program~radioactivity radioactivity program~radioactivity->proc~create_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~create_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~create_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/clear_tracks.html"},{"title":"copy_section – ForSynth","text":"public  subroutine copy_section(self, from_track, to_track, t1, t2, t3) Copy section t1...t2 at t3, either on the same track or another one.\nThe content already present at t3 is overwritten.\nThe code suppose that t1 < t2 < t3. Type Bound tape_recorder Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: from_track integer, intent(in) :: to_track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: t3 Called by proc~~copy_section~~CalledByGraph proc~copy_section tape_recorder%copy_section program~chords_and_melody chords_and_melody program~chords_and_melody->proc~copy_section program~demo_effects demo_effects program~demo_effects->proc~copy_section Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/copy_section.html"},{"title":"finalize – ForSynth","text":"public  subroutine finalize(self) Called by the close_WAV_file() method. Type Bound tape_recorder Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self Called by proc~~finalize~~CalledByGraph proc~finalize tape_recorder%finalize proc~close_wav_file WAV_file%close_WAV_file proc~close_wav_file->proc~finalize program~all_signals all_signals program~all_signals->proc~close_wav_file program~arpeggios arpeggios program~arpeggios->proc~close_wav_file program~blues blues program~blues->proc~close_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~close_wav_file program~demo_effects demo_effects program~demo_effects->proc~close_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~close_wav_file program~drone_music drone_music program~drone_music->proc~close_wav_file program~drum_machine drum_machine program~drum_machine->proc~close_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~close_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~close_wav_file program~radioactivity radioactivity program~radioactivity->proc~close_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~close_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~close_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/finalize.html"},{"title":"mix_tracks – ForSynth","text":"public  subroutine mix_tracks(self, levels, pan) Tracks 1 to tracks-1 are mixed on track 0. Type Bound tape_recorder Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: levels real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: pan Called by proc~~mix_tracks~~CalledByGraph proc~mix_tracks tape_recorder%mix_tracks program~all_signals all_signals program~all_signals->proc~mix_tracks program~arpeggios arpeggios program~arpeggios->proc~mix_tracks program~blues blues program~blues->proc~mix_tracks program~chords_and_melody chords_and_melody program~chords_and_melody->proc~mix_tracks program~demo_effects demo_effects program~demo_effects->proc~mix_tracks program~doppler_effect doppler_effect program~doppler_effect->proc~mix_tracks program~drone_music drone_music program~drone_music->proc~mix_tracks program~drum_machine drum_machine program~drum_machine->proc~mix_tracks program~misc_sounds misc_sounds program~misc_sounds->proc~mix_tracks program~multiplication_bells multiplication_bells program~multiplication_bells->proc~mix_tracks program~radioactivity radioactivity program~radioactivity->proc~mix_tracks program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~mix_tracks program~shepard_scale shepard_scale program~shepard_scale->proc~mix_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mix_tracks.html"},{"title":"new – ForSynth","text":"public  subroutine new(self, tracks, duration) Type Bound tape_recorder Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration Calls proc~~new~~CallsGraph proc~new tape_recorder%new proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~new~~CalledByGraph proc~new tape_recorder%new proc~create_wav_file WAV_file%create_WAV_file proc~create_wav_file->proc~new program~all_signals all_signals program~all_signals->proc~create_wav_file program~arpeggios arpeggios program~arpeggios->proc~create_wav_file program~blues blues program~blues->proc~create_wav_file program~chords_and_melody chords_and_melody program~chords_and_melody->proc~create_wav_file program~demo_effects demo_effects program~demo_effects->proc~create_wav_file program~doppler_effect doppler_effect program~doppler_effect->proc~create_wav_file program~drone_music drone_music program~drone_music->proc~create_wav_file program~drum_machine drum_machine program~drum_machine->proc~create_wav_file program~misc_sounds misc_sounds program~misc_sounds->proc~create_wav_file program~multiplication_bells multiplication_bells program~multiplication_bells->proc~create_wav_file program~radioactivity radioactivity program~radioactivity->proc~create_wav_file program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~create_wav_file program~shepard_scale shepard_scale program~shepard_scale->proc~create_wav_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/new.html"},{"title":"amplitude – ForSynth","text":"function amplitude(freq) Envelope of the glissando. A gaussian, plus linear sections at\nthe extremities, to reach the 0 level. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: freq Return Value real(kind=wp) Calls proc~~amplitude~~CallsGraph proc~amplitude amplitude proc~linear1 linear1 proc~amplitude->proc~linear1 proc~linear2 linear2 proc~amplitude->proc~linear2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~amplitude~~CalledByGraph proc~amplitude amplitude proc~write_amplitude_envelope write_amplitude_envelope proc~write_amplitude_envelope->proc~amplitude program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~amplitude Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/amplitude.html"},{"title":"linear1 – ForSynth","text":"function linear1(freq, f1, f2) Returns an amplitude rising from 0 to 1, from f1 to f2. And 0 outside. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: freq real(kind=wp), intent(in) :: f1 real(kind=wp), intent(in) :: f2 Return Value real(kind=wp) Called by proc~~linear1~~CalledByGraph proc~linear1 linear1 proc~amplitude amplitude proc~amplitude->proc~linear1 proc~write_amplitude_envelope write_amplitude_envelope proc~write_amplitude_envelope->proc~amplitude program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~amplitude Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/linear1.html"},{"title":"linear2 – ForSynth","text":"function linear2(freq, f1, f2) Returns an amplitude falling from 1 to 0, from f1 to f2. And 0 outside. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: freq real(kind=wp), intent(in) :: f1 real(kind=wp), intent(in) :: f2 Return Value real(kind=wp) Called by proc~~linear2~~CalledByGraph proc~linear2 linear2 proc~amplitude amplitude proc~amplitude->proc~linear2 proc~write_amplitude_envelope write_amplitude_envelope proc~write_amplitude_envelope->proc~amplitude program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~amplitude Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/linear2.html"},{"title":"initialize_frequencies – ForSynth","text":"subroutine initialize_frequencies() Arguments None Called by proc~~initialize_frequencies~~CalledByGraph proc~initialize_frequencies initialize_frequencies program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~initialize_frequencies Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/initialize_frequencies.html"},{"title":"write_amplitude_envelope – ForSynth","text":"subroutine write_amplitude_envelope() Useful for debugging and setting the envelope parameters: Arguments None Calls proc~~write_amplitude_envelope~~CallsGraph proc~write_amplitude_envelope write_amplitude_envelope proc~amplitude amplitude proc~write_amplitude_envelope->proc~amplitude proc~linear1 linear1 proc~amplitude->proc~linear1 proc~linear2 linear2 proc~amplitude->proc~linear2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/write_amplitude_envelope.html"},{"title":"fit_exp – ForSynth","text":"public pure function fit_exp(x, x1, y1, x2, y2) Returns an exponential interpolation y(x) between (x1,y1) and (x2,y2).\nUseful for computing an exponentially decreasing enveloppe. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: x1 real(kind=wp), intent(in) :: y1 real(kind=wp), intent(in) :: x2 real(kind=wp), intent(in) :: y2 Return Value real(kind=wp) Called by proc~~fit_exp~~CalledByGraph proc~fit_exp fit_exp proc~add_bell add_bell proc~add_bell->proc~fit_exp program~multiplication_bells multiplication_bells program~multiplication_bells->proc~add_bell Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/fit_exp.html"},{"title":"ADSR_level – ForSynth","text":"private pure function ADSR_level(self, t, t1, t2) Returns the level in [0, 1] of the ADSR envelope at time t1 < t < t2 Type Bound ADSR_envelope Arguments Type Intent Optional Attributes Name class( ADSR_envelope ), intent(in) :: self real(kind=wp), intent(in) :: t real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 Return Value real(kind=wp) Called by proc~~adsr_level~~CalledByGraph proc~adsr_level ADSR_envelope%ADSR_level proc~add_noise add_noise proc~add_noise->proc~adsr_level proc~add_sawtooth_wave add_sawtooth_wave proc~add_sawtooth_wave->proc~adsr_level proc~add_sine_wave add_sine_wave proc~add_sine_wave->proc~adsr_level proc~add_square_wave add_square_wave proc~add_square_wave->proc~adsr_level proc~add_triangle_wave add_triangle_wave proc~add_triangle_wave->proc~adsr_level proc~add_weierstrass add_weierstrass proc~add_weierstrass->proc~adsr_level proc~add_morse_code add_morse_code proc~add_morse_code->proc~add_sine_wave proc~add_note add_note proc~add_note->proc~add_sine_wave program~all_signals all_signals program~all_signals->proc~add_noise program~all_signals->proc~add_sawtooth_wave program~all_signals->proc~add_sine_wave program~all_signals->proc~add_square_wave program~all_signals->proc~add_triangle_wave program~all_signals->proc~add_weierstrass proc~add_chord add_chord proc~add_chord->proc~add_note program~radioactivity radioactivity program~radioactivity->proc~add_morse_code program~radioactivity->proc~add_chord program~chords_and_melody chords_and_melody program~chords_and_melody->proc~add_chord program~demo_effects demo_effects program~demo_effects->proc~add_chord Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure real ( wp ) function ADSR_level ( self , t , t1 , t2 ) class ( ADSR_envelope ), intent ( in ) :: self real ( wp ), intent ( in ) :: t , t1 , t2 integer :: i , i1 , i2 , i3 , i4 , i5 i = nint ( t * RATE ) ! First part (Attack): i1 = nint ( t1 * RATE ) i2 = nint (( t1 + ( t2 - t1 ) * self % attack / 10 0.0_wp ) * RATE ) if (( i >= i1 ) . and . ( i < i2 )) then ADSR_level = ( i - i1 ) / real ( i2 - i1 , wp ) else i3 = nint (( t1 + ( t2 - t1 ) * ( self % attack + self % decay ) / 10 0.0_wp ) * RATE ) if (( i >= i2 ) . and . ( i < i3 )) then ADSR_level = ( 10 0.0_wp - ( i - i2 ) / real ( i3 - i2 , wp ) * & & ( 10 0.0_wp - self % sustain )) / 10 0.0_wp else i4 = nint (( t2 - ( t2 - t1 ) * self % release / 10 0.0_wp ) * RATE ) if (( i >= i3 ) . and . ( i < i4 )) then ADSR_level = ( self % sustain / 10 0.0_wp ) else i5 = nint ( t2 * RATE ) if (( i >= i4 ) . and . ( i <= i5 )) then ADSR_level = ( self % sustain - ( i - i4 ) / real ( i5 - i4 , wp ) * & & self % sustain ) / 10 0.0_wp else ! ERROR ADSR_level: t outside [t1, t2] ADSR_level = 1.0_wp end if end if end if end if end function ADSR_level","tags":"","loc":"proc/adsr_level.html"},{"title":"apply_fade_in – ForSynth","text":"public  subroutine apply_fade_in(tape, track, t1, t2) A linear fade in, from relative level 0 to 1: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 Called by proc~~apply_fade_in~~CalledByGraph proc~apply_fade_in apply_fade_in program~drone_music drone_music program~drone_music->proc~apply_fade_in program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~apply_fade_in Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apply_fade_in ( tape , track , t1 , t2 ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 integer :: i , i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 do concurrent ( i = i1 : i2 ) tape % left ( track , i ) = tape % left ( track , i ) * ( i - i1 ) / ( i2 - i1 ) tape % right ( track , i ) = tape % right ( track , i ) * ( i - i1 ) / ( i2 - i1 ) end do end subroutine apply_fade_in","tags":"","loc":"proc/apply_fade_in.html"},{"title":"apply_fade_out – ForSynth","text":"public  subroutine apply_fade_out(tape, track, t1, t2) A linear fade out, from relative level 1 to 0: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 Called by proc~~apply_fade_out~~CalledByGraph proc~apply_fade_out apply_fade_out program~arpeggios arpeggios program~arpeggios->proc~apply_fade_out program~drone_music drone_music program~drone_music->proc~apply_fade_out program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->proc~apply_fade_out Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apply_fade_out ( tape , track , t1 , t2 ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 integer :: i , i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 do concurrent ( i = i1 : i2 ) tape % left ( track , i ) = tape % left ( track , i ) * (( i - i2 ) / real ( i1 - i2 , kind = wp )) tape % right ( track , i ) = tape % right ( track , i ) * (( i - i2 ) / real ( i1 - i2 , kind = wp )) end do end subroutine apply_fade_out","tags":"","loc":"proc/apply_fade_out.html"},{"title":"ADSR_new – ForSynth","text":"private  subroutine ADSR_new(self, A, D, S, R) Type Bound ADSR_envelope Arguments Type Intent Optional Attributes Name class( ADSR_envelope ), intent(inout) :: self real(kind=wp), intent(in) :: A real(kind=wp), intent(in) :: D real(kind=wp), intent(in) :: S real(kind=wp), intent(in) :: R Called by proc~~adsr_new~~CalledByGraph proc~adsr_new ADSR_envelope%ADSR_new program~all_signals all_signals program~all_signals->proc~adsr_new program~chords_and_melody chords_and_melody program~chords_and_melody->proc~adsr_new program~demo_effects demo_effects program~demo_effects->proc~adsr_new program~radioactivity radioactivity program~radioactivity->proc~adsr_new Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine ADSR_new ( self , A , D , S , R ) class ( ADSR_envelope ), intent ( inout ) :: self real ( wp ), intent ( in ) :: A , D , S , R self % attack = A self % decay = D self % sustain = S self % release = R end subroutine ADSR_new","tags":"","loc":"proc/adsr_new.html"},{"title":"forsynth – ForSynth","text":"This module contains a few parameters, especially the sampling frequency and\nthe temporal step. Uses iso_fortran_env module~~forsynth~~UsesGraph module~forsynth forsynth iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forsynth~~UsedByGraph module~forsynth forsynth module~audio_effects audio_effects module~audio_effects->module~forsynth module~tape_recorder_class tape_recorder_class module~audio_effects->module~tape_recorder_class module~envelopes envelopes module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class module~music music module~music->module~forsynth module~music->module~envelopes module~signals signals module~music->module~signals module~music->module~tape_recorder_class module~signals->module~forsynth module~signals->module~envelopes module~signals->module~tape_recorder_class module~tape_recorder_class->module~forsynth module~wav_file_class wav_file_class module~wav_file_class->module~forsynth module~wav_file_class->module~tape_recorder_class program~all_signals all_signals program~all_signals->module~forsynth program~all_signals->module~envelopes program~all_signals->module~music program~all_signals->module~signals program~all_signals->module~wav_file_class program~arpeggios arpeggios program~arpeggios->module~forsynth program~arpeggios->module~envelopes program~arpeggios->module~music program~arpeggios->module~signals program~arpeggios->module~wav_file_class program~blues blues program~blues->module~forsynth program~blues->module~audio_effects program~blues->module~music program~blues->module~signals program~blues->module~wav_file_class program~chords_and_melody chords_and_melody program~chords_and_melody->module~forsynth program~chords_and_melody->module~audio_effects program~chords_and_melody->module~envelopes program~chords_and_melody->module~music program~chords_and_melody->module~signals program~chords_and_melody->module~wav_file_class program~demo_effects demo_effects program~demo_effects->module~forsynth program~demo_effects->module~audio_effects program~demo_effects->module~envelopes program~demo_effects->module~music program~demo_effects->module~wav_file_class program~doppler_effect doppler_effect program~doppler_effect->module~forsynth program~doppler_effect->module~wav_file_class program~drone_music drone_music program~drone_music->module~forsynth program~drone_music->module~envelopes program~drone_music->module~music program~drone_music->module~wav_file_class program~drum_machine drum_machine program~drum_machine->module~forsynth program~drum_machine->module~signals program~drum_machine->module~wav_file_class program~misc_sounds misc_sounds program~misc_sounds->module~forsynth program~misc_sounds->module~music program~misc_sounds->module~tape_recorder_class program~misc_sounds->module~wav_file_class program~multiplication_bells multiplication_bells program~multiplication_bells->module~forsynth program~multiplication_bells->module~music program~multiplication_bells->module~signals program~multiplication_bells->module~wav_file_class program~radioactivity radioactivity program~radioactivity->module~forsynth program~radioactivity->module~envelopes program~radioactivity->module~music program~radioactivity->module~tape_recorder_class program~radioactivity->module~wav_file_class module~morse_code morse_code program~radioactivity->module~morse_code program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->module~forsynth program~shepard_risset_glissando->module~envelopes program~shepard_risset_glissando->module~wav_file_class program~shepard_scale shepard_scale program~shepard_scale->module~forsynth program~shepard_scale->module~audio_effects program~shepard_scale->module~wav_file_class module~morse_code->module~signals module~morse_code->module~tape_recorder_class Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: PI = 4.0_wp*atan(1.0_wp) integer, public, parameter :: RATE = 44100 real(kind=wp), public, parameter :: dt = 1.0_wp/RATE integer, public, parameter :: wp = REAL64 The default working precision wp is REAL64.\nREAL32 can be set: it will accelerate computations and give good results\nmost of the time. But in certain situations, for example drone music, it\ncan introduce artefacts. Subroutines public  subroutine test_the_machine () A WAV file contains 64, 32 and 16 bits data or metadata,\nso we need those kinds. Arguments None","tags":"","loc":"module/forsynth.html"},{"title":"music_common – ForSynth","text":"Contains music theory elements: scales, circle of fifths, chords, etc. This file will be kept identical in the ForMIDI and ForSynth projects.\n It could be put in a separate fpm repository and used as a dependency,\n but for the time being, synchronizing it by hand is sufficient. Used by module~~music_common~~UsedByGraph module~music_common music_common module~music music module~music->module~music_common program~arpeggios arpeggios program~arpeggios->module~music_common program~arpeggios->module~music program~blues blues program~blues->module~music_common program~blues->module~music program~chords_and_melody chords_and_melody program~chords_and_melody->module~music_common program~chords_and_melody->module~music program~demo_effects demo_effects program~demo_effects->module~music_common program~demo_effects->module~music program~radioactivity radioactivity program~radioactivity->module~music_common program~radioactivity->module~music program~all_signals all_signals program~all_signals->module~music program~drone_music drone_music program~drone_music->module~music program~misc_sounds misc_sounds program~misc_sounds->module~music program~multiplication_bells multiplication_bells program~multiplication_bells->module~music Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=2), public, parameter,               dimension(1:12) :: CHROMATIC_SCALE = ['C ', 'C#', 'D ', 'D#', 'E ', 'F ', 'F#', 'G ', 'G#', 'A ', 'A#', 'B '] We define some scales, excluding the octave of the first note.\nAlways use the trim() function to remove trailing spaces.\nhttps://en.wikipedia.org/wiki/Scale_(music) character(len=2), public, dimension(1:12) :: CIRCLE_OF_FIFTHS_MAJOR = ['C ', 'G ', 'D ', 'A ', 'E ', 'B ', 'Gb', 'Db', 'Ab', 'Eb', 'Bb', 'F '] Always use the trim() function to remove trailing spaces. character(len=2), public, dimension(1:12) :: CIRCLE_OF_FIFTHS_MINOR = ['A ', 'E ', 'B ', 'F#', 'C#', 'G#', 'Eb', 'Bb', 'F ', 'C ', 'G ', 'D '] integer, public, parameter :: CLUSTER_CHORD (1:12) = [(j, j=0, 11)] integer, public, parameter :: DOMINANT_7TH_CHORD (1:4) = [0, 4, 7, 10] character(len=2), public, parameter,               dimension(1:7) :: HARMONIC_MINOR_SCALE = ['A ', 'B ', 'C ', 'D ', 'E ', 'F ', 'G#'] https://en.wikipedia.org/wiki/Minor_scale#Harmonic_minor_scale character(len=2), public, parameter,               dimension(1:6) :: HEXATONIC_BLUES_SCALE = ['C ', 'Eb', 'F ', 'Gb', 'G ', 'Bb'] https://en.wikipedia.org/wiki/Hexatonic_scale#Blues_scale integer, public, parameter :: MAJOR_CHORD (1:3) = [0, 4, 7] Some frequent chords.\nThese arrays can be passed to the write_chord() subroutine.\nhttps://en.wikipedia.org/wiki/Chord_(music) character(len=1), public, parameter,               dimension(1:5) :: MAJOR_PENTATONIC_SCALE = ['C', 'D', 'E', 'G', 'A'] https://en.wikipedia.org/wiki/Pentatonic_scale#Major_pentatonic_scale character(len=1), public, parameter,               dimension(1:7) :: MAJOR_SCALE = ['C', 'D', 'E', 'F', 'G', 'A', 'B'] https://en.wikipedia.org/wiki/Major_scale integer, public, parameter :: MINOR_CHORD (1:3) = [0, 3, 7] integer, public, parameter :: POWER_CHORD (1:3) = [0, 7, 12] integer, public, parameter :: SUS2_CHORD (1:3) = [0, 2, 7] integer, public, parameter :: SUS4_CHORD (1:3) = [0, 5, 7] character(len=2), public, parameter,               dimension(1:6) :: WHOLE_TONE_SCALE = ['C ', 'D ', 'E ', 'F#', 'G#', 'A#'] integer, private :: j","tags":"","loc":"module/music_common.html"},{"title":"signals – ForSynth","text":"Subroutines generating different kind of signals Uses tape_recorder_class forsynth envelopes module~~signals~~UsesGraph module~signals signals module~envelopes envelopes module~signals->module~envelopes module~forsynth forsynth module~signals->module~forsynth module~tape_recorder_class tape_recorder_class module~signals->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~signals~~UsedByGraph module~signals signals module~morse_code morse_code module~morse_code->module~signals module~music music module~music->module~signals program~all_signals all_signals program~all_signals->module~signals program~all_signals->module~music program~arpeggios arpeggios program~arpeggios->module~signals program~arpeggios->module~music program~blues blues program~blues->module~signals program~blues->module~music program~chords_and_melody chords_and_melody program~chords_and_melody->module~signals program~chords_and_melody->module~music program~drum_machine drum_machine program~drum_machine->module~signals program~multiplication_bells multiplication_bells program~multiplication_bells->module~signals program~multiplication_bells->module~music program~demo_effects demo_effects program~demo_effects->module~music program~drone_music drone_music program~drone_music->module~music program~misc_sounds misc_sounds program~misc_sounds->module~music program~radioactivity radioactivity program~radioactivity->module~morse_code program~radioactivity->module~music Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function weierstrass (a, b, x) https://en.wikipedia.org/wiki/Weierstrass_function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: x Return Value real(kind=wp) Subroutines public  subroutine add_bell (tape, track, t1, f, Amp) Adds a Risset bell sound on the track at t1.\nJean-Claude Risset, An Introductory Catalogue Of Computer Synthesized Sounds,\nBell Telephone Laboratories  Murray Hill, New Jersey, 1969. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp public  subroutine add_karplus_strong (tape, track, t1, t2, f, Amp) Karplus and Strong algorithm (1983), for plucked-string\nhttp://crypto.stanford.edu/~blynn/sound/karplusstrong.html\nhttps://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp public  subroutine add_karplus_strong_drum (tape, track, t1, t2, P, Amp) Karplus and Strong (1983) algorithm for obtaining a percussion sound.\nTypically, P is taken to be between 150 and 1000.\nCaution: this algorithm overwrites what may have existed on the\ntrack at the chosen location.\nYou may also want to modify the b parameter to make some weird sounds,\nsomewhere between percussion and guitar...\nhttp://crypto.stanford.edu/~blynn/sound/karplusstrong.html\nhttps://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 integer, intent(in) :: P real(kind=wp), intent(in) :: Amp public  subroutine add_karplus_strong_drum_stretched (tape, track, t1, t2, P, Amp) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 integer, intent(in) :: P real(kind=wp), intent(in) :: Amp public  subroutine add_karplus_strong_stretched (tape, track, t1, t2, f, Amp) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp public  subroutine add_noise (tape, track, t1, t2, Amp, envelope) Add white noise on the track: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope public  subroutine add_sawtooth_wave (tape, track, t1, t2, f, Amp, envelope) Adds on the track a sawtooth wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope public  subroutine add_sine_wave (tape, track, t1, t2, f, Amp, envelope) Adds on the track a sine wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope public  subroutine add_square_wave (tape, track, t1, t2, f, Amp, envelope) Adds on the track a square wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope public  subroutine add_triangle_wave (tape, track, t1, t2, f, Amp, envelope) Adds on the track a triangle wave with an ADSR envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope public  subroutine add_weierstrass (tape, track, t1, t2, f, Amp, envelope) Add a fractal signal on the track with an envelope: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(in), optional :: envelope","tags":"","loc":"module/signals.html"},{"title":"music – ForSynth","text":"Contains music theory elements: scales, circle of fifths, chords, etc. Uses music_common signals forsynth tape_recorder_class envelopes module~~music~~UsesGraph module~music music module~envelopes envelopes module~music->module~envelopes module~forsynth forsynth module~music->module~forsynth module~music_common music_common module~music->module~music_common module~signals signals module~music->module~signals module~tape_recorder_class tape_recorder_class module~music->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~music~~UsedByGraph module~music music program~all_signals all_signals program~all_signals->module~music program~arpeggios arpeggios program~arpeggios->module~music program~blues blues program~blues->module~music program~chords_and_melody chords_and_melody program~chords_and_melody->module~music program~demo_effects demo_effects program~demo_effects->module~music program~drone_music drone_music program~drone_music->module~music program~misc_sounds misc_sounds program~misc_sounds->module~music program~multiplication_bells multiplication_bells program~multiplication_bells->module~music program~radioactivity radioactivity program~radioactivity->module~music Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: PITCH = 440.0_wp Concert pitch (A note): real(kind=wp), public, parameter :: SEMITONE = 2.0_wp**(1.0_wp/12.0_wp) Equal temperament: https://en.wikipedia.org/wiki/Equal_temperament Functions public  function fr (note) Returns the frequency of the note.\nThe note name is composed of two or three characters,\nfor example \"A4\", \"A#4\", \"Ab4\", where the final character is\nthe octave. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: note Return Value real(kind=wp) Subroutines public  subroutine add_broken_chord (tape, track, t1, t2, f, Amp, chord) Writes a broken chord using an array containing the intervals\n(see the music_common module). It uses plucked strings (Karplus-Strong).\nFor the moment, each note has the same duration.\nhttps://en.wikipedia.org/wiki/Arpeggio Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp integer, intent(in), dimension(:) :: chord public  subroutine add_chord (tape, track, t1, t2, f, Amp, chord, envelope) Writes a chord using an array containing the intervals\n(see the music_common module) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp integer, intent(in), dimension(:) :: chord type( ADSR_envelope ), intent(inout), optional :: envelope public  subroutine add_note (tape, track, t1, t2, f, Amp, envelope) A note of fundamental frequency f with harmonics, based on sine waves.\nhttps://en.wikipedia.org/wiki/Harmonic Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp type( ADSR_envelope ), intent(inout), optional :: envelope","tags":"","loc":"module/music.html"},{"title":"audio_effects – ForSynth","text":"Various audio effects Uses tape_recorder_class forsynth module~~audio_effects~~UsesGraph module~audio_effects audio_effects module~forsynth forsynth module~audio_effects->module~forsynth module~tape_recorder_class tape_recorder_class module~audio_effects->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~audio_effects~~UsedByGraph module~audio_effects audio_effects program~blues blues program~blues->module~audio_effects program~chords_and_melody chords_and_melody program~chords_and_melody->module~audio_effects program~demo_effects demo_effects program~demo_effects->module~audio_effects program~shepard_scale shepard_scale program~shepard_scale->module~audio_effects Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine apply_autopan_effect (tape, track, t1, t2, f, AmpLFO) Make the sound move from one channel to the other one at a frequency f\nand with an amplitude AmpLFO in [0 ; 1]. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: AmpLFO public  subroutine apply_delay_effect (tape, track, t1, t2, delay, Amp) Add the sound from \"delay\" seconds before,\nand multiply by Amp<1 for dampening. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: delay real(kind=wp), intent(in) :: Amp public  subroutine apply_fuzz_effect (tape, track, t1, t2, level) Apply distorsion with hard clipping\nhttps://en.wikipedia.org/wiki/Distortion_(music) Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: level public  subroutine apply_reverse_effect (tape, track, t1, t2) Copy the samples at the same t1 but in reverse order: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 public  subroutine apply_tremolo_effect (tape, track, t1, t2, f, AmpLFO) A sinusoidal modulation of the amplitude of a signal (tremolo) :\nf : tremolo frequency (typically a few Hz)\nAmpLFO : tremolo amplitude in [0 ; 1]\nhttps://en.wikipedia.org/wiki/Vibrato#Vibrato_and_tremolo/ Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: AmpLFO","tags":"","loc":"module/audio_effects.html"},{"title":"wav_file_class – ForSynth","text":"The main class that you will use to create your WAV files. Uses iso_fortran_env tape_recorder_class forsynth module~~wav_file_class~~UsesGraph module~wav_file_class wav_file_class iso_fortran_env iso_fortran_env module~wav_file_class->iso_fortran_env module~forsynth forsynth module~wav_file_class->module~forsynth module~tape_recorder_class tape_recorder_class module~wav_file_class->module~tape_recorder_class module~forsynth->iso_fortran_env module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~wav_file_class~~UsedByGraph module~wav_file_class wav_file_class program~all_signals all_signals program~all_signals->module~wav_file_class program~arpeggios arpeggios program~arpeggios->module~wav_file_class program~blues blues program~blues->module~wav_file_class program~chords_and_melody chords_and_melody program~chords_and_melody->module~wav_file_class program~demo_effects demo_effects program~demo_effects->module~wav_file_class program~doppler_effect doppler_effect program~doppler_effect->module~wav_file_class program~drone_music drone_music program~drone_music->module~wav_file_class program~drum_machine drum_machine program~drum_machine->module~wav_file_class program~misc_sounds misc_sounds program~misc_sounds->module~wav_file_class program~multiplication_bells multiplication_bells program~multiplication_bells->module~wav_file_class program~radioactivity radioactivity program~radioactivity->module~wav_file_class program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->module~wav_file_class program~shepard_scale shepard_scale program~shepard_scale->module~wav_file_class Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: MAX_AMPLITUDE = 32767 Maximum amplitude in a WAV [-32768 ; +32767]: integer, private :: status Derived Types type, public, extends( tape_recorder ) :: WAV_file Components Type Visibility Attributes Name Initial real(kind=wp), public :: duration Duration in seconds: character(len=:), public, allocatable :: filename integer, public :: fileunit real(kind=wp), public, dimension(:, :), allocatable :: left Two arrays stocking the stereo tracks: real(kind=wp), public, dimension(:, :), allocatable :: right Two arrays stocking the stereo tracks: integer, public :: samples Number of samples: integer, public :: tracks Number of audio tracks (excluding track 0 reserved for the final mix): Type-Bound Procedures procedure, public :: clear_tracks procedure, public :: close_WAV_file procedure, public :: copy_section procedure, public :: create_WAV_file procedure, public :: finalize procedure, public :: get_name procedure, public :: mix_tracks procedure, public :: new procedure, private :: write_header procedure, private :: write_normalized_data Functions public  function get_name (self) Returns the name of the WAV file: Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self Return Value character(len=len(self%filename)) Subroutines public  subroutine close_WAV_file (self) Must be called at the end. It normalizes the channels, writes them in the\nWAV file and closes it. It also deallocate the tape arrays. Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self public  subroutine create_WAV_file (self, filename, tracks, duration) Create a WAV file with a header: Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self character(len=*), intent(in) :: filename integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration public  subroutine write_header (self) Creates the 44 bytes WAV header and prints some information: Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self WAV parameters: Read more… public  subroutine write_normalized_data (self) This method normalizes the sound amplitude on track 0, before saving\nthe left and right channels in the WAV file. Arguments Type Intent Optional Attributes Name class( WAV_file ), intent(inout) :: self","tags":"","loc":"module/wav_file_class.html"},{"title":"morse_code – ForSynth","text":"Basic Morse code support.\nhttps://en.wikipedia.org/wiki/Morse_code Uses signals tape_recorder_class module~~morse_code~~UsesGraph module~morse_code morse_code module~signals signals module~morse_code->module~signals module~tape_recorder_class tape_recorder_class module~morse_code->module~tape_recorder_class module~signals->module~tape_recorder_class module~envelopes envelopes module~signals->module~envelopes module~forsynth forsynth module~signals->module~forsynth module~tape_recorder_class->module~forsynth module~envelopes->module~tape_recorder_class module~envelopes->module~forsynth iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~morse_code~~UsedByGraph module~morse_code morse_code program~radioactivity radioactivity program~radioactivity->module~morse_code Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=5), private, parameter :: morse_table (36) = ['.-   ', '-... ', '-.-. ', '-..  ', '.    ', '..-. ', '--.  ', '.... ', '..   ', '.--- ', '-.-  ', '.-.. ', '--   ', '-.   ', '---  ', '.--. ', '--.- ', '.-.  ', '...  ', '-    ', '..-  ', '...- ', '.--  ', '-..- ', '-.-- ', '--.. ', '-----', '.----', '..---', '...--', '....-', '.....', '-....', '--...', '---..', '----.'] Functions public  function string_to_morse (string) result(morse) This function receives a string and returns its Morse code translation.\nThe input string can contain only alphabetic characters in upper or lower case,\ndigits 0..9 and spaces. All other characters will be considered as spaces.\nCharacters inside words are separated by one space, and words by two spaces. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Subroutines public  subroutine add_morse_code (tape, track, t1, f, Amp, string) Adds on the specified track a Morse code translation of the string, starting at\ntime t1. The frequency f must correspond to a high tone, for example 880 Hz. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp character(len=*), intent(in) :: string","tags":"","loc":"module/morse_code.html"},{"title":"tape_recorder_class – ForSynth","text":"This is the basic class, representing a numeric tape recorder with audio tracks. Uses forsynth module~~tape_recorder_class~~UsesGraph module~tape_recorder_class tape_recorder_class module~forsynth forsynth module~tape_recorder_class->module~forsynth iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~tape_recorder_class~~UsedByGraph module~tape_recorder_class tape_recorder_class module~audio_effects audio_effects module~audio_effects->module~tape_recorder_class module~envelopes envelopes module~envelopes->module~tape_recorder_class module~morse_code morse_code module~morse_code->module~tape_recorder_class module~signals signals module~morse_code->module~signals module~music music module~music->module~tape_recorder_class module~music->module~envelopes module~music->module~signals module~signals->module~tape_recorder_class module~signals->module~envelopes module~wav_file_class wav_file_class module~wav_file_class->module~tape_recorder_class program~misc_sounds misc_sounds program~misc_sounds->module~tape_recorder_class program~misc_sounds->module~music program~misc_sounds->module~wav_file_class program~radioactivity radioactivity program~radioactivity->module~tape_recorder_class program~radioactivity->module~envelopes program~radioactivity->module~morse_code program~radioactivity->module~music program~radioactivity->module~wav_file_class program~all_signals all_signals program~all_signals->module~envelopes program~all_signals->module~music program~all_signals->module~signals program~all_signals->module~wav_file_class program~arpeggios arpeggios program~arpeggios->module~envelopes program~arpeggios->module~music program~arpeggios->module~signals program~arpeggios->module~wav_file_class program~blues blues program~blues->module~audio_effects program~blues->module~music program~blues->module~signals program~blues->module~wav_file_class program~chords_and_melody chords_and_melody program~chords_and_melody->module~audio_effects program~chords_and_melody->module~envelopes program~chords_and_melody->module~music program~chords_and_melody->module~signals program~chords_and_melody->module~wav_file_class program~demo_effects demo_effects program~demo_effects->module~audio_effects program~demo_effects->module~envelopes program~demo_effects->module~music program~demo_effects->module~wav_file_class program~doppler_effect doppler_effect program~doppler_effect->module~wav_file_class program~drone_music drone_music program~drone_music->module~envelopes program~drone_music->module~music program~drone_music->module~wav_file_class program~drum_machine drum_machine program~drum_machine->module~signals program~drum_machine->module~wav_file_class program~multiplication_bells multiplication_bells program~multiplication_bells->module~music program~multiplication_bells->module~signals program~multiplication_bells->module~wav_file_class program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->module~envelopes program~shepard_risset_glissando->module~wav_file_class program~shepard_scale shepard_scale program~shepard_scale->module~audio_effects program~shepard_scale->module~wav_file_class Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: tape_recorder Components Type Visibility Attributes Name Initial real(kind=wp), public :: duration Duration in seconds: real(kind=wp), public, dimension(:, :), allocatable :: left Two arrays stocking the stereo tracks: real(kind=wp), public, dimension(:, :), allocatable :: right Two arrays stocking the stereo tracks: integer, public :: samples Number of samples: integer, public :: tracks Number of audio tracks (excluding track 0 reserved for the final mix): Finalizations Procedures final :: auto_finalize Type-Bound Procedures procedure, public :: clear_tracks procedure, public :: copy_section procedure, public :: finalize procedure, public :: mix_tracks procedure, public :: new Subroutines public  subroutine auto_finalize (self) An automatic finalizer, by security. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: self public  subroutine clear_tracks (self) Erase all tracks on all the channels of the tape. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self public  subroutine copy_section (self, from_track, to_track, t1, t2, t3) Copy section t1...t2 at t3, either on the same track or another one.\nThe content already present at t3 is overwritten.\nThe code suppose that t1 < t2 < t3. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: from_track integer, intent(in) :: to_track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: t3 public  subroutine finalize (self) Called by the close_WAV_file() method. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self public  subroutine mix_tracks (self, levels, pan) Tracks 1 to tracks-1 are mixed on track 0. Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: levels real(kind=wp), intent(in), optional, dimension(1:self%tracks) :: pan public  subroutine new (self, tracks, duration) Arguments Type Intent Optional Attributes Name class( tape_recorder ), intent(inout) :: self integer, intent(in) :: tracks real(kind=wp), intent(in) :: duration","tags":"","loc":"module/tape_recorder_class.html"},{"title":"envelopes – ForSynth","text":"Functions and subroutines generating envelopes Uses tape_recorder_class forsynth module~~envelopes~~UsesGraph module~envelopes envelopes module~forsynth forsynth module~envelopes->module~forsynth module~tape_recorder_class tape_recorder_class module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~envelopes~~UsedByGraph module~envelopes envelopes module~music music module~music->module~envelopes module~signals signals module~music->module~signals module~signals->module~envelopes program~all_signals all_signals program~all_signals->module~envelopes program~all_signals->module~music program~all_signals->module~signals program~arpeggios arpeggios program~arpeggios->module~envelopes program~arpeggios->module~music program~arpeggios->module~signals program~chords_and_melody chords_and_melody program~chords_and_melody->module~envelopes program~chords_and_melody->module~music program~chords_and_melody->module~signals program~demo_effects demo_effects program~demo_effects->module~envelopes program~demo_effects->module~music program~drone_music drone_music program~drone_music->module~envelopes program~drone_music->module~music program~radioactivity radioactivity program~radioactivity->module~envelopes program~radioactivity->module~music module~morse_code morse_code program~radioactivity->module~morse_code program~shepard_risset_glissando shepard_risset_glissando program~shepard_risset_glissando->module~envelopes module~morse_code->module~signals program~blues blues program~blues->module~music program~blues->module~signals program~drum_machine drum_machine program~drum_machine->module~signals program~misc_sounds misc_sounds program~misc_sounds->module~music program~multiplication_bells multiplication_bells program~multiplication_bells->module~music program~multiplication_bells->module~signals Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: ADSR_envelope Components Type Visibility Attributes Name Initial real(kind=wp), public :: attack = 30.0_wp A   D S   R\n   /\\\n  /  ____\n /        \\\n/          \\\nhttps://en.wikipedia.org/wiki/Envelope_(music)\nDefault parameters of the ADSR envelope: real(kind=wp), public :: decay = 20.0_wp real(kind=wp), public :: release = 30.0_wp real(kind=wp), public :: sustain = 80.0_wp Type-Bound Procedures procedure, public :: get_level => ADSR_level procedure, public :: new => ADSR_new Functions public pure function fit_exp (x, x1, y1, x2, y2) Returns an exponential interpolation y(x) between (x1,y1) and (x2,y2).\nUseful for computing an exponentially decreasing enveloppe. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: x1 real(kind=wp), intent(in) :: y1 real(kind=wp), intent(in) :: x2 real(kind=wp), intent(in) :: y2 Return Value real(kind=wp) private pure function ADSR_level (self, t, t1, t2) Returns the level in [0, 1] of the ADSR envelope at time t1 < t < t2 Arguments Type Intent Optional Attributes Name class( ADSR_envelope ), intent(in) :: self real(kind=wp), intent(in) :: t real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 Return Value real(kind=wp) Subroutines public  subroutine apply_fade_in (tape, track, t1, t2) A linear fade in, from relative level 0 to 1: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 public  subroutine apply_fade_out (tape, track, t1, t2) A linear fade out, from relative level 1 to 0: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 private  subroutine ADSR_new (self, A, D, S, R) Arguments Type Intent Optional Attributes Name class( ADSR_envelope ), intent(inout) :: self real(kind=wp), intent(in) :: A real(kind=wp), intent(in) :: D real(kind=wp), intent(in) :: S real(kind=wp), intent(in) :: R","tags":"","loc":"module/envelopes.html"},{"title":"multiplication_bells – ForSynth","text":"Uses signals music wav_file_class forsynth program~~multiplication_bells~~UsesGraph program~multiplication_bells multiplication_bells module~forsynth forsynth program~multiplication_bells->module~forsynth module~music music program~multiplication_bells->module~music module~signals signals program~multiplication_bells->module~signals module~wav_file_class wav_file_class program~multiplication_bells->module~wav_file_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~forsynth module~music->module~signals module~envelopes envelopes module~music->module~envelopes module~music_common music_common module~music->module~music_common module~tape_recorder_class tape_recorder_class module~music->module~tape_recorder_class module~signals->module~forsynth module~signals->module~envelopes module~signals->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. An example with a lot of bells, either periodic or random.\nhttps://en.wikipedia.org/wiki/Campanology Calls program~~multiplication_bells~~CallsGraph program~multiplication_bells multiplication_bells proc~add_bell add_bell program~multiplication_bells->proc~add_bell proc~close_wav_file WAV_file%close_WAV_file program~multiplication_bells->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~multiplication_bells->proc~create_wav_file proc~get_name WAV_file%get_name program~multiplication_bells->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~multiplication_bells->proc~mix_tracks proc~fit_exp fit_exp proc~add_bell->proc~fit_exp proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo real(kind=wp), parameter :: dnote = 3._wp integer :: i integer, parameter :: iend = 15 real(kind=wp) :: r1 real(kind=wp) :: r2 real(kind=wp) :: r3 integer, parameter :: shift (0:5) = [4, 7, 10, 12, 16, 19] real(kind=wp), parameter :: t2 = 75._wp Source Code program multiplication_bells use forsynth , only : wp use wav_file_class , only : WAV_file , tape_recorder use music , only : SEMITONE , PITCH use signals , only : add_bell implicit none type ( WAV_file ) :: demo ! Total duration in seconds: real ( wp ), parameter :: t2 = 7 5._wp ! Duration of the basic note: real ( wp ), parameter :: dnote = 3._wp ! Semitones for major third, fifth, 7th, octave, major third, fifth: integer , parameter :: shift ( 0 : 5 ) = [ 4 , 7 , 10 , 12 , 16 , 19 ] integer , parameter :: iend = 15 ! Nb of periods for the periodic bells integer :: i ! Loop counter real ( wp ) :: r1 , r2 , r3 ! Random numbers ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'multiplication_bells.wav' , tracks = 1 , duration = t2 ) print * , \"**** Creating \" // demo % get_name () // \" ****\" print * , \"Be patient, it may take up to one minute...\" associate ( tape => demo % tape_recorder ) ! Intro: call add_bell ( tape , track = 1 , t1 = 0._wp , f = PITCH * SEMITONE ** ( - 7 ), Amp = 2._wp ) ! Periodic bells: do i = 1 , iend call add_bell ( tape , track = 1 , t1 = i * dnote , f = PITCH * SEMITONE ** ( - 4 ), Amp = 1._wp ) call add_bell ( tape , track = 1 , t1 = i * dnote + dnote / 4 , f = PITCH * SEMITONE ** ( 0 ) , Amp = 1._wp ) call add_bell ( tape , track = 1 , t1 = i * dnote + 3 * dnote / 4 , f = PITCH * SEMITONE ** ( 0 ) , Amp = 1._wp ) end do ! Random bells: do i = 1 , 100 call random_number ( r1 ) ! Starting time call random_number ( r2 ) ! Tone call random_number ( r3 ) ! Amplitude call add_bell ( tape , track = 1 , t1 = 4._wp + ( iend - 2 ) * dnote * r1 , f = PITCH * SEMITONE ** ( shift ( int ( r2 * 6 ))), Amp = 1._wp * r3 ) end do ! Outro: call add_bell ( tape , track = 1 , t1 = ( iend + 2 ) * dnote , f = PITCH * SEMITONE ** ( - 7 ), Amp = 2._wp ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program multiplication_bells","tags":"","loc":"program/multiplication_bells.html"},{"title":"drone_music – ForSynth","text":"Uses music wav_file_class forsynth envelopes program~~drone_music~~UsesGraph program~drone_music drone_music module~envelopes envelopes program~drone_music->module~envelopes module~forsynth forsynth program~drone_music->module~forsynth module~music music program~drone_music->module~music module~wav_file_class wav_file_class program~drone_music->module~wav_file_class module~envelopes->module~forsynth module~tape_recorder_class tape_recorder_class module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~envelopes module~music->module~forsynth module~music_common music_common module~music->module~music_common module~signals signals module~music->module~signals module~music->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Experimental drone music. Calls program~~drone_music~~CallsGraph program~drone_music drone_music proc~apply_fade_in apply_fade_in program~drone_music->proc~apply_fade_in proc~apply_fade_out apply_fade_out program~drone_music->proc~apply_fade_out proc~close_wav_file WAV_file%close_WAV_file program~drone_music->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~drone_music->proc~create_wav_file proc~get_name WAV_file%get_name program~drone_music->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~drone_music->proc~mix_tracks proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=wp) :: Amp type( WAV_file ) :: demo real(kind=wp) :: f0 real(kind=wp) :: f1 real(kind=wp) :: f2 integer :: i real(kind=wp) :: omega1 real(kind=wp) :: omega2 real(kind=wp) :: omegaLFO1 real(kind=wp) :: omegaLFO2 real(kind=wp) :: t real(kind=wp) :: t1 real(kind=wp) :: t2 Source Code program drone_music use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use music , only : SEMITONE use envelopes , only : apply_fade_in , apply_fade_out implicit none type ( WAV_file ) :: demo ! Time in seconds: real ( wp ) :: t , t1 , t2 , f0 , f1 , f2 ! Pulsation (radians/second): real ( wp ) :: omega1 , omega2 , omegaLFO1 , omegaLFO2 real ( wp ) :: Amp integer :: i ! Fundamental frequency: f0 = 8 0._wp ! Low Frequency Oscillators: omegaLFO1 = 2 * PI * 0.03_wp omegaLFO2 = 2 * PI * 0.001_wp Amp = 1._wp print * , \"**** Creating drone_music.wav ****\" t1 = 0._wp t2 = 18 0._wp ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'drone_music.wav' , tracks = 1 , duration = t2 ) associate ( tape => demo % tape_recorder ) t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 ! Fundamental: f1 = f0 * ( 1 + 0.01_wp * sin ( omegaLFO1 * t )) omega1 = 2 * PI * f1 tape % left ( 1 , i ) = Amp * sin ( omega1 * t ) ! Perfect fifth (7 semitones higher): f2 = f0 * ( SEMITONE ** 7 ) * ( 1 + 0.01_wp * sin ( omegaLFO2 * t )) omega2 = 2 * PI * f2 tape % left ( 1 , i ) = tape % left ( 1 , i ) + Amp * sin ( omega2 * t ) tape % right ( 1 , i ) = tape % left ( 1 , i ) t = t + dt end do call apply_fade_in ( tape , track = 1 , t1 = 0._wp , t2 = 3._wp ) call apply_fade_out ( tape , track = 1 , t1 = t2 - 3 , t2 = t2 ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program drone_music","tags":"","loc":"program/drone_music.html"},{"title":"misc_sounds – ForSynth","text":"Uses music wav_file_class forsynth tape_recorder_class program~~misc_sounds~~UsesGraph program~misc_sounds misc_sounds module~forsynth forsynth program~misc_sounds->module~forsynth module~music music program~misc_sounds->module~music module~tape_recorder_class tape_recorder_class program~misc_sounds->module~tape_recorder_class module~wav_file_class wav_file_class program~misc_sounds->module~wav_file_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~forsynth module~music->module~tape_recorder_class module~envelopes envelopes module~music->module~envelopes module~music_common music_common module~music->module~music_common module~signals signals module~music->module~signals module~tape_recorder_class->module~forsynth module~wav_file_class->module~forsynth module~wav_file_class->module~tape_recorder_class module~wav_file_class->iso_fortran_env module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class module~signals->module~forsynth module~signals->module~tape_recorder_class module~signals->module~envelopes Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Miscellaneous signals, especially obtained by frequency or phase modulation.\nA WAV file is created for each sound. Calls program~~misc_sounds~~CallsGraph program~misc_sounds misc_sounds proc~add_misc_signal add_misc_signal program~misc_sounds->proc~add_misc_signal proc~close_wav_file WAV_file%close_WAV_file program~misc_sounds->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~misc_sounds->proc~create_wav_file proc~fr fr program~misc_sounds->proc~fr proc~get_name WAV_file%get_name program~misc_sounds->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~misc_sounds->proc~mix_tracks proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo integer :: i character(len=2) :: number Subroutines subroutine add_misc_signal (tape, track, t1, t2, f, Amp, choice) Add on the track a signal choosen by its number: Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp integer, intent(in) :: choice Source Code program misc_sounds use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use tape_recorder_class use music , only : fr implicit none type ( WAV_file ) :: demo integer :: i character ( 2 ) :: number print * , \"**** Creating misc_sounds WAV files ****\" do i = 0 , 23 print * , i write ( number , '(I0)' ) i ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'misc_sounds' // trim ( number ) // '.wav' , tracks = 1 , duration = 3 0._wp ) ! We call the subroutine for signal i: call add_misc_signal ( demo % tape_recorder , track = 1 , t1 = 0._wp , t2 = 3 0._wp , f = fr ( \"A4\" ), Amp = 1._wp , choice = i ) ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () end do print * , \"You can now play the file \" , demo % get_name () contains !> Add on the track a signal choosen by its number: subroutine add_misc_signal ( tape , track , t1 , t2 , f , Amp , choice ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , choice real ( wp ), intent ( in ) :: t1 , t2 , f , Amp ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t real ( wp ), parameter :: phi = - 3 * PI ! Phase in radians at t=0 integer :: i , j omega = 2 * PI * f t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 select case ( choice ) case ( 0 ) ! Pure sinus tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) case ( 1 ) ! Science fiction signal... tape % left ( track , i ) = + Amp * sin ( omega * t + phi * cos ( 75 * t ) / ( 1 + log ( t / 100 + 0.01_wp ))) case ( 2 ) ! Hummmmmmmmmm... tape % left ( track , i ) = + Amp * sin ( omega * t + phi * sin ( omega * 0.2_wp * t )) case ( 3 ) ! UFO or siren? tape % left ( track , i ) = + Amp * sin ( omega * t + phi * cos ( 25 * t )) case ( 4 ) ! Noisy science fiction tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( t * 50 )) * t + phi ) case ( 5 ) ! Whistling, slower and slower... tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( sqrt ( t ) * 50 )) * t + phi ) case ( 6 ) ! Similar tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( log ( t ) * 50 )) * t + phi ) case ( 7 ) ! Dudududududu... tape % left ( track , i ) = + Amp * sin ( t * 30 ) * sin ( omega * t + phi ) case ( 8 ) ! Duuuuuuuuuuuuuuuuuuu tape % left ( track , i ) = + Amp * sin ( omega * t + phi * ( 0.5_wp + 0.5_wp * sin ( t * 500 ))) case ( 9 ) ! A higher duuuuuuuuuuuuuuuuuuu tape % left ( track , i ) = + Amp / 2 * sin ( omega * t + phi ) + Amp / 2 * sin ( omega * 1.1892_wp * t + phi ) case ( 10 ) ! Higher and higher... tape % left ( track , i ) = + Amp * sin (( omega * ( 1 + t / 10 )) * t + phi ) case ( 11 ) ! Dampening slowly do j = 1 , 7 tape % left ( track , i ) = + Amp / ( j * ( 1 + t ** j )) * sin ( j * omega * t ) end do case ( 12 ) ! Vibrato tape % left ( track , i ) = + Amp * sin ( omega * t + phi * ( 1._wp + 0.5_wp * sin ( 2 * PI * 4 * t ))) case ( 13 ) ! A mix tape % left ( track , i ) = + Amp * sin ( t ) * sin ( omega * t + phi ) & & + Amp * cos ( 2.5_wp * t ) * sin ( 1.5_wp * omega * t + phi ) + Amp * sin ( 3 * t ) * sin ( 2 * omega * t + phi ) case ( 14 ) ! Tremolo tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) + Amp * sin ( 1.001_wp * omega * t + phi ) & & + Amp * sin ( 0.999_wp * omega * t + phi ) case ( 15 ) ! Poke... (a short percussion based on the Sinc function) if ( omega * t + phi /= 0._wp ) then tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) / ( omega * t + phi ) else tape % left ( track , i ) = + Amp end if case ( 16 ) ! Science fiction, becoming higher and noisy tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.001_wp * sin ( t * 500 )) * t + phi ) case ( 17 ) ! Dissonant tape % left ( track , i ) = + Amp * sin ( omega * t + 4 * sin ( omega / 10 * t )) case ( 18 ) ! Dampening tape % left ( track , i ) = + Amp * ( 1 / ( 1 + t ** 3 )) * sin ( omega * t + 2 * sin ( omega * t + 3 * sin ( omega * t ))) case ( 19 ) ! Science-fiction, becoming higher and noisy tape % left ( track , i ) = + Amp * & & sin ( omega * ( 1._wp + 0.001_wp * sin ( t * 500 * ( 1._wp + 0.0002_wp * cos ( t * 50 )))) * t + phi ) case ( 20 ) ! Another dampening sound tape % left ( track , i ) = + Amp * ( exp ( - t ) * sin ( omega * t ) + 0.5_wp * exp ( - t ** 2 ) * sin ( 2 * omega * t ) & & + 0.25_wp * exp ( - t ** 3 ) * sin ( 3 * omega * t ) + 0.12_wp * exp ( - t ** 4 ) * sin ( 4 * omega * t )) case ( 21 ) ! Dampening slowly do j = 1 , 14 tape % left ( track , i ) = + Amp / ( j ** 2 * ( 1 + t ** j )) * sin ( j * omega * t ) end do case ( 22 ) ! Clarinet do j = 1 , 11 , + 2 tape % left ( track , i ) = + Amp / j ** 0.7_wp * sin ( j * omega * t ) end do case ( 23 ) ! Bessel function of the first kind J1: pong... tape % left ( track , i ) = + Amp * bessel_jn ( 1 , omega * t ) case ( 24 ) ! Bessel functions of the first kind: ping (far shorter) tape % left ( track , i ) = + Amp * bessel_jn ( 1 , omega * t ) * bessel_jn ( 2 , omega * t ) end select tape % right ( track , i ) = tape % left ( track , i ) t = t + dt end do end subroutine add_misc_signal end program misc_sounds","tags":"","loc":"program/misc_sounds.html"},{"title":"blues – ForSynth","text":"Uses music_common audio_effects signals forsynth music wav_file_class program~~blues~~UsesGraph program~blues blues module~audio_effects audio_effects program~blues->module~audio_effects module~forsynth forsynth program~blues->module~forsynth module~music music program~blues->module~music module~music_common music_common program~blues->module~music_common module~signals signals program~blues->module~signals module~wav_file_class wav_file_class program~blues->module~wav_file_class module~audio_effects->module~forsynth module~tape_recorder_class tape_recorder_class module~audio_effects->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~forsynth module~music->module~music_common module~music->module~signals module~envelopes envelopes module~music->module~envelopes module~music->module~tape_recorder_class module~signals->module~forsynth module~signals->module~envelopes module~signals->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A random walk on a blues scale. Calls program~~blues~~CallsGraph program~blues blues proc~add_karplus_strong add_karplus_strong program~blues->proc~add_karplus_strong proc~apply_tremolo_effect apply_tremolo_effect program~blues->proc~apply_tremolo_effect proc~close_wav_file WAV_file%close_WAV_file program~blues->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~blues->proc~create_wav_file proc~fr fr program~blues->proc~fr proc~get_name WAV_file%get_name program~blues->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~blues->proc~mix_tracks proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo real(kind=wp) :: dnote integer :: i integer :: k real(kind=wp) :: r real(kind=wp) :: t Source Code program blues use forsynth , only : wp use wav_file_class , only : WAV_file use signals , only : add_karplus_strong use music , only : fr use music_common , only : HEXATONIC_BLUES_SCALE use audio_effects , only : apply_tremolo_effect implicit none type ( WAV_file ) :: demo real ( wp ) :: t , dnote real ( wp ) :: r ! Random number integer :: i , k print * , \"**** Demo Blues ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'blues.wav' , tracks = 1 , duration = 3 5._wp ) associate ( tape => demo % tape_recorder ) ! Notes duration in seconds: dnote = 0.5_wp t = 0.0_wp print * , \"A blues scale\" t = t + dnote do i = 1 , 6 call add_karplus_strong ( tape , track = 1 , t1 = t , t2 = t + dnote , & & f = fr ( trim ( HEXATONIC_BLUES_SCALE ( i )) // '3' ), Amp = 1.0_wp ) t = t + dnote end do print * , \"Random walk on that blues scale\" k = 1 do i = 1 , 60 call random_number ( r ) if ( r < 0.5_wp ) then k = k - 1 else k = k + 1 end if if ( k < 1 ) k = 1 if ( k > 6 ) k = 6 call random_number ( r ) r = min ( 1.0_wp , r + 0.25_wp ) call add_karplus_strong ( tape , track = 1 , t1 = t , t2 = t + dnote * ( r + 0.25_wp ), & & f = fr ( trim ( HEXATONIC_BLUES_SCALE ( k )) // '2' ), Amp = 1.0_wp ) t = t + dnote * ( r + 0.25_wp ) end do ! A tremolo at 3 Hz and an amplitude of 0.2: call apply_tremolo_effect ( tape , track = 1 , t1 = 0.0_wp , t2 = t , f = 3.0_wp , AmpLFO = 0.2_wp ) end associate print * , \"Final mix...\" ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program blues","tags":"","loc":"program/blues.html"},{"title":"drum_machine – ForSynth","text":"Uses signals wav_file_class forsynth program~~drum_machine~~UsesGraph program~drum_machine drum_machine module~forsynth forsynth program~drum_machine->module~forsynth module~signals signals program~drum_machine->module~signals module~wav_file_class wav_file_class program~drum_machine->module~wav_file_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~signals->module~forsynth module~envelopes envelopes module~signals->module~envelopes module~tape_recorder_class tape_recorder_class module~signals->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A rhythm following a pattern stored in an array. Calls program~~drum_machine~~CallsGraph program~drum_machine drum_machine proc~add_karplus_strong_drum add_karplus_strong_drum program~drum_machine->proc~add_karplus_strong_drum proc~add_karplus_strong_drum_stretched add_karplus_strong_drum_stretched program~drum_machine->proc~add_karplus_strong_drum_stretched proc~close_wav_file WAV_file%close_WAV_file program~drum_machine->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~drum_machine->proc~create_wav_file proc~get_name WAV_file%get_name program~drum_machine->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~drum_machine->proc~mix_tracks proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo integer :: i integer :: j integer, dimension(3, 16) :: pattern = reshape([1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], shape(pattern), order=[2, 1]) real(kind=wp) :: step = 0.25_wp real(kind=wp) :: t Source Code program drum_machine use forsynth , only : wp use wav_file_class , only : WAV_file use signals , only : add_karplus_strong_drum , add_karplus_strong_drum_stretched implicit none type ( WAV_file ) :: demo integer :: i , j real ( wp ) :: t real ( wp ) :: step = 0.25_wp ! Each line is a different drum: integer , dimension ( 3 , 16 ) :: pattern = reshape ( [ & 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , & 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , & 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ], & shape ( pattern ), order = [ 2 , 1 ] ) print * , \"**** Demo Drum Machine****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'drum_machine.wav' , tracks = 3 , duration = 3 3._wp ) associate ( tape => demo % tape_recorder ) ! A rhythm following the above pattern: t = 0._wp do i = 1 , 8 do j = 1 , 16 ! We use one track for each kind of drum: if ( pattern ( 1 , j ) == 1 ) then call add_karplus_strong_drum ( tape , track = 1 , t1 = t , t2 = t + 2 * step , P = 150 , Amp = 1._wp ) end if if ( pattern ( 2 , j ) == 1 ) then call add_karplus_strong_drum ( tape , track = 2 , t1 = t , t2 = t + 2 * step , P = 400 , Amp = 1._wp ) end if if ( pattern ( 3 , j ) == 1 ) then call add_karplus_strong_drum_stretched ( tape , track = 3 , t1 = t , t2 = t + 2 * step , P = 150 , Amp = 0.5_wp ) end if t = t + step end do end do end associate print * , \"Final mix...\" ! The three drums are positionned on the left, the center and the right: call demo % mix_tracks ( pan = [ - 0.5_wp , 0._wp , + 0.5_wp ]) call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program drum_machine","tags":"","loc":"program/drum_machine.html"},{"title":"demo_effects – ForSynth","text":"Uses music_common audio_effects forsynth music wav_file_class envelopes program~~demo_effects~~UsesGraph program~demo_effects demo_effects module~audio_effects audio_effects program~demo_effects->module~audio_effects module~envelopes envelopes program~demo_effects->module~envelopes module~forsynth forsynth program~demo_effects->module~forsynth module~music music program~demo_effects->module~music module~music_common music_common program~demo_effects->module~music_common module~wav_file_class wav_file_class program~demo_effects->module~wav_file_class module~audio_effects->module~forsynth module~tape_recorder_class tape_recorder_class module~audio_effects->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~envelopes module~music->module~forsynth module~music->module~music_common module~signals signals module~music->module~signals module~music->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. All available audio effects are applied sequentially on a chord sequence. Calls program~~demo_effects~~CallsGraph program~demo_effects demo_effects proc~add_chord add_chord program~demo_effects->proc~add_chord proc~adsr_new ADSR_envelope%ADSR_new program~demo_effects->proc~adsr_new proc~apply_autopan_effect apply_autopan_effect program~demo_effects->proc~apply_autopan_effect proc~apply_delay_effect apply_delay_effect program~demo_effects->proc~apply_delay_effect proc~apply_fuzz_effect apply_fuzz_effect program~demo_effects->proc~apply_fuzz_effect proc~apply_tremolo_effect apply_tremolo_effect program~demo_effects->proc~apply_tremolo_effect proc~close_wav_file WAV_file%close_WAV_file program~demo_effects->proc~close_wav_file proc~copy_section tape_recorder%copy_section program~demo_effects->proc~copy_section proc~create_wav_file WAV_file%create_WAV_file program~demo_effects->proc~create_wav_file proc~fr fr program~demo_effects->proc~fr proc~get_name WAV_file%get_name program~demo_effects->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~demo_effects->proc~mix_tracks proc~add_note add_note proc~add_chord->proc~add_note proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~add_sine_wave add_sine_wave proc~add_note->proc~add_sine_wave proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo real(kind=wp) :: dnote type( ADSR_envelope ) :: env integer :: i real(kind=wp) :: t Source Code program demo_effects use forsynth , only : wp use wav_file_class , only : WAV_file use music_common , only : MAJOR_CHORD use music , only : fr , add_chord use audio_effects , only : apply_fuzz_effect , apply_tremolo_effect , & & apply_autopan_effect , apply_delay_effect use envelopes , only : ADSR_envelope implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env integer :: i real ( wp ) :: t , dnote print * , \"**** Demo of the audio effects ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'demo_effects.wav' , tracks = 1 , duration = 12 0._wp ) ! We create an ADSR envelope that will be passed to signals (add_chord): call env % new ( A = 1 0._wp , D = 4 0._wp , S = 8 0._wp , R = 3 0._wp ) ! Notes duration in seconds: dnote = 1.5_wp associate ( tape => demo % tape_recorder ) print * , \"Track 1: repeating G D F C chords...\" t = 0.0_wp call add_chord ( tape , track = 1 , t1 = t , t2 = t + dnote , f = fr ( \"G3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + dnote , t2 = t + 2 * dnote , f = fr ( \"D3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 2 * dnote , t2 = t + 3 * dnote , f = fr ( \"F3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 3 * dnote , t2 = t + 4 * dnote , f = fr ( \"C3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) ! Repeat those four chords until the end of the track: do i = 1 , 19 call demo % copy_section ( from_track = 1 , to_track = 1 , t1 = t , t2 = t + 4 * dnote , t3 = 4 * dnote * i ) end do ! Apply the different effects, every four chords, ! after four chords without effect: call apply_fuzz_effect ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 8 * dnote , level = 0.8_wp ) call apply_tremolo_effect ( tape , track = 1 , t1 = t + 8 * dnote , t2 = t + 12 * dnote , f = 4.0_wp , AmpLFO = 0.3_wp ) call apply_autopan_effect ( tape , track = 1 , t1 = t + 12 * dnote , t2 = t + 16 * dnote , f = 0.33_wp , AmpLFO = 0.8_wp ) call apply_delay_effect ( tape , track = 1 , t1 = t + 16 * dnote , t2 = t + 20 * dnote , delay = 0.4_wp , Amp = 0.4_wp ) end associate print * , \"Final mix...\" ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program demo_effects","tags":"","loc":"program/demo_effects.html"},{"title":"doppler_effect – ForSynth","text":"Uses wav_file_class forsynth program~~doppler_effect~~UsesGraph program~doppler_effect doppler_effect module~forsynth forsynth program~doppler_effect->module~forsynth module~wav_file_class wav_file_class program~doppler_effect->module~wav_file_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~tape_recorder_class tape_recorder_class module~wav_file_class->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A simulation of Doppler effect, with a car passing in front of you.\nhttps://fr.wikipedia.org/wiki/Effet_Doppler\nThe Observer is static at the origin,\nthe car is Moving along x at a constant velocity v\n                       &#94; y\n                       | *M * y0 * *>\n                       |\n----x0-----------------O-------------------> x\n                       |\nThe frequency perceived by the observer (Doppler effect)\nis fobs = f / (1 - vr/c) but we don't need to compute it.\nThe signal heard by the observer at tobs was emitted earlier by the\ncar at t, from a distance r(t):\ntobs = t + r(t) / c\nBy developing r(t) we can finally obtain a quadratic equation:\n(c *2-v 2) * t 2 - (2 tobs c 2 + 2 x0 v) t + (tobs 2 * c 2 - x0 2 - y *2) = 0\nThe time t is the unique physical solution of that equation: The amplitude of the observed signal is decreasing in r**2: Calls program~~doppler_effect~~CallsGraph program~doppler_effect doppler_effect proc~close_wav_file WAV_file%close_WAV_file program~doppler_effect->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~doppler_effect->proc~create_wav_file proc~get_name WAV_file%get_name program~doppler_effect->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~doppler_effect->proc~mix_tracks proc~the_solution the_solution program~doppler_effect->proc~the_solution proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=wp) :: Amp real(kind=wp), parameter :: c = 343 type( WAV_file ) :: demo real(kind=wp), parameter :: duration = 7._wp real(kind=wp), parameter :: f = 50 integer :: i integer :: j real(kind=wp) :: omega real(kind=wp) :: panL real(kind=wp) :: panR real(kind=wp) :: t real(kind=wp) :: tobs real(kind=wp), parameter :: v = 130000._wp/3600 real(kind=wp) :: x real(kind=wp) :: x0 real(kind=wp) :: y real(kind=wp), parameter :: y0 = 10 Functions function the_solution (a, b, c, tobs) We solve the Quadratic equation,\nbut physically one and only one solution can exist:\nwe know the sound was emitted before we hear it!> Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: c real(kind=wp), intent(in) :: tobs Return Value real(kind=wp) Source Code program doppler_effect use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file implicit none type ( WAV_file ) :: demo real ( wp ) :: panL , panR ! Pulsation (radians/second): real ( wp ) :: omega real ( wp ) :: t , tobs real ( wp ) :: Amp integer :: i , j real ( wp ) :: x0 , x , y real ( wp ), parameter :: duration = 7._wp ! Duration in seconds real ( wp ), parameter :: y0 = 10 ! m real ( wp ), parameter :: v = 13000 0._wp / 3600 ! 130 km/h (car velocity) ! https://en.wikipedia.org/wiki/Speed_of_sound real ( wp ), parameter :: c = 343 ! m/s at 20°C in air real ( wp ), parameter :: f = 50 ! Hz print * , \"**** Creating doppler_effect.wav ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'doppler_effect.wav' , tracks = 1 , duration = duration ) associate ( tape => demo % tape_recorder ) !> The Observer is static at the origin, !> the car is Moving along x at a constant velocity v !>                        &#94; y !>                        | !>      ****M*************y0**************> !>                        | !> ----x0-----------------O-------------------> x !>                        | omega = 2 * PI * f x0 = - v * duration / 2 ! y is constant: y = y0 print '(3A8, A10, 2A8)' , \"tobs\" , \"t\" , \"x\" , \"Amp\" , \"panL\" , \"panR\" tobs = 0 do i = 0 , nint ( duration * RATE ) - 1 !> The frequency perceived by the observer (Doppler effect) !> is fobs = f / (1 - vr/c) but we don't need to compute it. !> The signal heard by the observer at tobs was emitted earlier by the !> car at t, from a distance r(t): !> tobs = t + r(t) / c !> By developing r(t) we can finally obtain a quadratic equation: !> (c**2-v**2) * t**2 - (2*tobs*c**2 + 2*x0*v) *t + (tobs**2 * c**2 - x0**2 - y**2) = 0 !> The time t is the unique physical solution of that equation: t = the_solution ( a = c ** 2 - v ** 2 , b =- ( 2 * tobs * c ** 2 + 2 * x0 * v ), c = ( tobs ** 2 * c ** 2 - x0 ** 2 - y ** 2 ), tobs = tobs ) ! The position of the car at t was: x = x0 + v * t !> The amplitude of the observed signal is decreasing in r**2: Amp = 1 / ( x ** 2 + y ** 2 ) ! We simulate a stereo effect by using this arbitrary law: ! (note that x0<0 and at tobs=0 x<x0) panR = abs (( max ( x , x0 ) - x0 ) / ( 2 * x0 )) panL = 1 - panR tape % left ( 1 , i ) = panL * Amp * sin ( omega * t ) tape % right ( 1 , i ) = panR * Amp * sin ( omega * t ) ! A signal with only even harmonics, to sound like a motor: do j = 2 , 40 , + 2 tape % left ( 1 , i ) = tape % left ( 1 , i ) + panL * Amp / j ** 1.3_wp * sin ( j * omega * t ) tape % right ( 1 , i ) = tape % right ( 1 , i ) + panR * Amp / j ** 1.3_wp * sin ( j * omega * t ) end do if ( mod ( i , RATE / 4 ) == 0 ) print '(3F8.2, ES10.2, 2F8.3)' , tobs , t , x , Amp , panL , panR tobs = tobs + dt end do end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () contains !> We solve the Quadratic equation, !> but physically one and only one solution can exist: !> we know the sound was emitted before we hear it!> real ( wp ) function the_solution ( a , b , c , tobs ) real ( wp ), intent ( in ) :: a , b , c , tobs real ( wp ) :: delta , t1 , t2 delta = b ** 2 - 4 * a * c if ( delta >= 0 ) then t1 = ( - b + sqrt ( delta )) / ( 2 * a ) t2 = ( - b - sqrt ( delta )) / ( 2 * a ) if ( t1 <= tobs ) then if ( t2 <= tobs ) then error stop \"ERROR: two solutions, physically impossible\" else the_solution = t1 end if else if ( t2 <= tobs ) then the_solution = t2 else error stop \"ERROR: no solution (1)\" end if else error stop \"ERROR: no solution, delta<0 (2)\" end if end function end program doppler_effect","tags":"","loc":"program/doppler_effect.html"},{"title":"radioactivity – ForSynth","text":"Uses music_common morse_code forsynth music wav_file_class tape_recorder_class envelopes program~~radioactivity~~UsesGraph program~radioactivity radioactivity module~envelopes envelopes program~radioactivity->module~envelopes module~forsynth forsynth program~radioactivity->module~forsynth module~morse_code morse_code program~radioactivity->module~morse_code module~music music program~radioactivity->module~music module~music_common music_common program~radioactivity->module~music_common module~tape_recorder_class tape_recorder_class program~radioactivity->module~tape_recorder_class module~wav_file_class wav_file_class program~radioactivity->module~wav_file_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~morse_code->module~tape_recorder_class module~signals signals module~morse_code->module~signals module~music->module~envelopes module~music->module~forsynth module~music->module~music_common module~music->module~tape_recorder_class module~music->module~signals module~tape_recorder_class->module~forsynth module~wav_file_class->module~forsynth module~wav_file_class->module~tape_recorder_class module~wav_file_class->iso_fortran_env module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Radioactive decay of a population of atoms. A tribute to Kraftwerk.\nChords are played on a 2nd track and Morse code on a third track. Calls program~~radioactivity~~CallsGraph program~radioactivity radioactivity proc~add_chord add_chord program~radioactivity->proc~add_chord proc~add_geiger_ping add_geiger_ping program~radioactivity->proc~add_geiger_ping proc~add_morse_code add_morse_code program~radioactivity->proc~add_morse_code proc~adsr_new ADSR_envelope%ADSR_new program~radioactivity->proc~adsr_new proc~close_wav_file WAV_file%close_WAV_file program~radioactivity->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~radioactivity->proc~create_wav_file proc~fr fr program~radioactivity->proc~fr proc~get_name WAV_file%get_name program~radioactivity->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~radioactivity->proc~mix_tracks proc~string_to_morse string_to_morse program~radioactivity->proc~string_to_morse proc~add_note add_note proc~add_chord->proc~add_note proc~add_sine_wave add_sine_wave proc~add_morse_code->proc~add_sine_wave proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~add_note->proc~add_sine_wave proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer :: N = N0 integer, parameter :: N0 = 5000 integer :: atom (N0) = 1 real(kind=wp) :: d_note real(kind=wp), parameter :: delta_t = tau/10000 type( WAV_file ) :: demo real(kind=wp), parameter :: duration = 120._wp type( ADSR_envelope ) :: env integer :: i integer :: j integer :: nb_notes integer :: note integer, parameter :: notes (1:40) = [6, 5, 6, 5, 6, 4, 5, 4, 5, 3, 4, 3, 4, 2, 3, 2, 3, 1, 2, 1, 2, 1, 3, 2, 3, 2, 4, 3, 4, 3, 5, 4, 5, 4, 6, 5, 6, 5, 6, 6] real(kind=wp), parameter :: p = 1-exp(-log(2._wp)*delta_t/tau) real(kind=wp) :: r real(kind=wp) :: t = 0 real(kind=wp) :: t_end real(kind=wp), parameter :: tau = 8._wp Subroutines subroutine add_geiger_ping (tape, track, t1, t2, f, Amp) Adds the signal of a radioactive decay heard with a Geiger counter. Arguments Type Intent Optional Attributes Name type( tape_recorder ), intent(inout) :: tape integer, intent(in) :: track real(kind=wp), intent(in) :: t1 real(kind=wp), intent(in) :: t2 real(kind=wp), intent(in) :: f real(kind=wp), intent(in) :: Amp Source Code program radioactivity use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use tape_recorder_class use music , only : fr , add_chord use music_common , only : WHOLE_TONE_SCALE , MAJOR_CHORD use envelopes , only : ADSR_envelope use morse_code , only : string_to_morse , add_morse_code implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env integer , parameter :: N0 = 5000 ! Number of atoms integer :: N = N0 ! Number of remaining radioactive atoms integer :: atom ( N0 ) = 1 ! The population of atoms, in state 1 real ( wp ) :: t = 0 ! Time in seconds real ( wp ) :: t_end ! Position of the end of the first track real ( wp ) :: d_note ! Duration of each chord real ( wp ), parameter :: duration = 12 0._wp ! Duration of the WAV file real ( wp ), parameter :: tau = 8._wp ! Half-life in seconds real ( wp ), parameter :: delta_t = tau / 10000 ! Time step of the simulation ! Decay probability during delta_t: real ( wp ), parameter :: p = 1 - exp ( - log ( 2._wp ) * delta_t / tau ) real ( wp ) :: r ! Pseudo-random number integer :: i , j , note , nb_notes ! Melody of the chords on track 2: integer , parameter :: notes ( 1 : 40 ) = [ 6 , 5 , 6 , 5 , 6 , 4 , 5 , 4 , 5 , 3 , 4 , 3 , 4 , 2 , 3 , 2 , 3 , 1 , 2 , & & 1 , 2 , 1 , 3 , 2 , 3 , 2 , 4 , 3 , 4 , 3 , 5 , 4 , 5 , 4 , 6 , 5 , 6 , 5 , 6 , 6 ] print * , \"It may take a few minutes to compute...\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'radioactivity.wav' , tracks = 3 , duration = duration ) ! We create an ADSR envelope that will be passed to signals (add_chord): call env % new ( A = 1 5._wp , D = 1 5._wp , S = 7 0._wp , R = 4 5._wp ) do ! Scanning the whole population: do i = 1 , N0 ! Is this atom still in its original state? if ( atom ( i ) /= 0 ) then ! Monte Carlo event: call random_number ( r ) if ( r < p ) then ! Radioactive decay atom ( i ) = 0 N = N - 1 if ( t + 5._wp < duration ) then call add_geiger_ping ( demo % tape_recorder , track = 1 , t1 = t , t2 = t + 5._wp , & & f = 44 0._wp , Amp = 1._wp ) end if end if end if end do t = t + delta_t if ( N == 0 ) exit ! No more radioactive atoms end do ! Track 2: synth chords t_end = t nb_notes = 2 * 40 d_note = t_end / nb_notes do j = 1 , nb_notes ! The same sequence is played twice: if ( j <= 40 ) then note = notes ( j ) else note = notes ( j - 40 ) end if call add_chord ( demo % tape_recorder , track = 2 , t1 = ( j - 1 ) * d_note , t2 = j * d_note , & & f = fr ( trim ( WHOLE_TONE_SCALE ( note )) // \"3\" ), & & Amp = 0.1_wp , chord = MAJOR_CHORD , envelope = env ) end do ! Track 3: Morse code call add_morse_code ( demo % tape_recorder , track = 3 , t1 = 2._wp , f = 88 0._wp , & & Amp = 0.3_wp , string = string_to_morse ( \"RADIOACTIVITY\" )) call add_morse_code ( demo % tape_recorder , track = 3 , t1 = 3 5._wp , f = 88 0._wp , & & Amp = 0.3_wp , string = string_to_morse ( \"DISCOVERED BY MADAME CURIE\" )) call add_morse_code ( demo % tape_recorder , track = 3 , t1 = 7 5._wp , f = 88 0._wp , & & Amp = 0.3_wp , string = string_to_morse ( \"IS IN THE AIR FOR YOU AND ME\" )) ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () contains !> Adds the signal of a radioactive decay heard with a Geiger counter. subroutine add_geiger_ping ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp real ( wp ) :: b ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t integer :: i omega = 2 * PI * f t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 ! Bessel functions of the first kind: a short ping b = Amp * bessel_jn ( 1 , omega * t ) * bessel_jn ( 2 , omega * t ) tape % left ( track , i ) = tape % left ( track , i ) + b tape % right ( track , i ) = tape % right ( track , i ) + b t = t + dt end do end subroutine add_geiger_ping end program radioactivity","tags":"","loc":"program/radioactivity.html"},{"title":"all_signals – ForSynth","text":"Uses signals forsynth music wav_file_class envelopes program~~all_signals~~UsesGraph program~all_signals all_signals module~envelopes envelopes program~all_signals->module~envelopes module~forsynth forsynth program~all_signals->module~forsynth module~music music program~all_signals->module~music module~signals signals program~all_signals->module~signals module~wav_file_class wav_file_class program~all_signals->module~wav_file_class module~envelopes->module~forsynth module~tape_recorder_class tape_recorder_class module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~envelopes module~music->module~forsynth module~music->module~signals module~music_common music_common module~music->module~music_common module~music->module~tape_recorder_class module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Plays sequentially each type of available signal. Calls program~~all_signals~~CallsGraph program~all_signals all_signals proc~add_karplus_strong add_karplus_strong program~all_signals->proc~add_karplus_strong proc~add_karplus_strong_stretched add_karplus_strong_stretched program~all_signals->proc~add_karplus_strong_stretched proc~add_noise add_noise program~all_signals->proc~add_noise proc~add_sawtooth_wave add_sawtooth_wave program~all_signals->proc~add_sawtooth_wave proc~add_sine_wave add_sine_wave program~all_signals->proc~add_sine_wave proc~add_square_wave add_square_wave program~all_signals->proc~add_square_wave proc~add_triangle_wave add_triangle_wave program~all_signals->proc~add_triangle_wave proc~add_weierstrass add_weierstrass program~all_signals->proc~add_weierstrass proc~adsr_new ADSR_envelope%ADSR_new program~all_signals->proc~adsr_new proc~close_wav_file WAV_file%close_WAV_file program~all_signals->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~all_signals->proc~create_wav_file proc~fr fr program~all_signals->proc~fr proc~get_name WAV_file%get_name program~all_signals->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~all_signals->proc~mix_tracks proc~adsr_level ADSR_envelope%ADSR_level proc~add_noise->proc~adsr_level proc~add_sawtooth_wave->proc~adsr_level proc~add_sine_wave->proc~adsr_level proc~add_square_wave->proc~adsr_level proc~add_triangle_wave->proc~adsr_level proc~add_weierstrass->proc~adsr_level proc~weierstrass weierstrass proc~add_weierstrass->proc~weierstrass proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo real(kind=wp) :: dnote type( ADSR_envelope ) :: env real(kind=wp) :: f_A real(kind=wp) :: t Source Code program all_signals use forsynth , only : wp use wav_file_class , only : WAV_file use music , only : fr use signals , only : add_sine_wave , add_square_wave , & & add_sawtooth_wave , add_triangle_wave , & & add_karplus_strong , add_karplus_strong_stretched , & & add_noise , add_weierstrass use envelopes , only : ADSR_envelope implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env real ( wp ) :: t , dnote real ( wp ) :: f_A print * , \"**** Demo of the available signals ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'all_signals.wav' , tracks = 1 , duration = 3 0._wp ) ! We create an ADSR envelope that will be passed to signals: call env % new ( A = 3 0._wp , D = 2 0._wp , S = 8 0._wp , R = 3 0._wp ) ! Notes frequencies are obtained with the fr() function: f_A = fr ( \"A3\" ) ! A 220 Hz ! Notes duration in seconds: dnote = 3.0_wp t = 0.0_wp associate ( tape => demo % tape_recorder ) ! We add each signal on the track between times t1 and t2: print * , \"Sinusoidal signal\" call add_sine_wave ( tape , track = 1 , t1 = t , t2 = t + dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Square wave\" call add_square_wave ( tape , track = 1 , t1 = t + dnote , t2 = t + 2 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Sawtooth wave\" call add_sawtooth_wave ( tape , track = 1 , t1 = t + 2 * dnote , t2 = t + 3 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Triangle wave\" call add_triangle_wave ( tape , track = 1 , t1 = t + 3 * dnote , t2 = t + 4 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Summing the four signals together\" call add_sine_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) call add_square_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) call add_sawtooth_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) call add_triangle_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) print * , \"Noise\" call add_noise ( tape , track = 1 , t1 = t + 5 * dnote , t2 = t + 6 * dnote , Amp = 1.0_wp , envelope = env ) print * , \"Weierstrass\" call add_weierstrass ( tape , track = 1 , t1 = t + 6 * dnote , t2 = t + 7 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Karplus Strong\" call add_karplus_strong ( tape , track = 1 , t1 = t + 7 * dnote , t2 = t + 8 * dnote , f = f_A , Amp = 1.0_wp ) print * , \"Karplus Strong stretched\" call add_karplus_strong_stretched ( tape , track = 1 , t1 = t + 8 * dnote , t2 = t + 9 * dnote , f = f_A , Amp = 1.0_wp ) end associate print * , \"Final mix...\" ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program all_signals","tags":"","loc":"program/all_signals.html"},{"title":"arpeggios – ForSynth","text":"Uses music_common signals forsynth music wav_file_class envelopes program~~arpeggios~~UsesGraph program~arpeggios arpeggios module~envelopes envelopes program~arpeggios->module~envelopes module~forsynth forsynth program~arpeggios->module~forsynth module~music music program~arpeggios->module~music module~music_common music_common program~arpeggios->module~music_common module~signals signals program~arpeggios->module~signals module~wav_file_class wav_file_class program~arpeggios->module~wav_file_class module~envelopes->module~forsynth module~tape_recorder_class tape_recorder_class module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~envelopes module~music->module~forsynth module~music->module~music_common module~music->module~signals module~music->module~tape_recorder_class module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arpeggios played in various ways using the circles of fifths\nhttps://en.wikipedia.org/wiki/Arpeggio Calls program~~arpeggios~~CallsGraph program~arpeggios arpeggios proc~add_broken_chord add_broken_chord program~arpeggios->proc~add_broken_chord proc~add_karplus_strong add_karplus_strong program~arpeggios->proc~add_karplus_strong proc~apply_fade_out apply_fade_out program~arpeggios->proc~apply_fade_out proc~close_wav_file WAV_file%close_WAV_file program~arpeggios->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~arpeggios->proc~create_wav_file proc~fr fr program~arpeggios->proc~fr proc~get_name WAV_file%get_name program~arpeggios->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~arpeggios->proc~mix_tracks proc~add_broken_chord->proc~add_karplus_strong proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( WAV_file ) :: demo real(kind=wp) :: dur integer :: i character(len=3) :: name real(kind=wp) :: t Source Code program arpeggios use forsynth , only : wp use wav_file_class , only : WAV_file use music_common , only : MINOR_CHORD , MAJOR_CHORD , & & CIRCLE_OF_FIFTHS_MAJOR , CIRCLE_OF_FIFTHS_MINOR use music , only : add_chord , add_broken_chord , fr , SEMITONE use signals , only : add_karplus_strong use envelopes , only : apply_fade_out implicit none type ( WAV_file ) :: demo integer :: i real ( wp ) :: t , dur character ( 3 ) :: name print * , \"**** Demo arpeggios ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'arpeggios.wav' , tracks = 2 , duration = 4 0._wp ) associate ( tape => demo % tape_recorder ) ! Chord duration in seconds: dur = 0.75_wp print * , \"Track 1: the circle of fifths major (left channel, octave 2)\" t = 0.0_wp do i = 1 , size ( CIRCLE_OF_FIFTHS_MAJOR ) name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" print * , i , name , fr ( name ) call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ) t = t + dur end do print * , \"The same, but the notes of each chord are played in an inverted order\" do i = 1 , size ( CIRCLE_OF_FIFTHS_MAJOR ) name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" print * , i , name , fr ( name ) call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ( 3 : 1 : - 1 )) t = t + dur end do print * , \"Counterclockwise, the circle of fourths\" do i = size ( CIRCLE_OF_FIFTHS_MAJOR ), 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ) t = t + dur end do print * , \"Once again, half the circle, slower and slower, with inverted arpeggios\" do i = size ( CIRCLE_OF_FIFTHS_MAJOR ) / 2 , 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ( 3 : 1 : - 1 )) t = t + dur dur = dur * 1.1_wp end do print * , \"We repeat the final chord\" call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ( 3 : 1 : - 1 )) call add_karplus_strong ( tape , track = 1 , t1 = t + dur , t2 = t + 5 * dur , f = fr ( name ) * SEMITONE ** MAJOR_CHORD ( 3 ), Amp = 1.0_wp ) print * , \"Track 2: the circle of fifths minor (right channel, octave 3)\" dur = 0.75_wp t = 0.0_wp do i = 1 , size ( CIRCLE_OF_FIFTHS_MINOR ) name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ) t = t + dur end do print * , \"The same, but the notes of each chord are played in an inverted order\" do i = 1 , size ( CIRCLE_OF_FIFTHS_MINOR ) name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ( 3 : 1 : - 1 )) t = t + dur end do print * , \"Counterclockwise, the circle of fourths\" do i = size ( CIRCLE_OF_FIFTHS_MINOR ), 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ) t = t + dur end do print * , \"Once again, half the circle, slower and slower, with inverted arpeggios\" do i = size ( CIRCLE_OF_FIFTHS_MINOR ) / 2 , 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ( 3 : 1 : - 1 )) t = t + dur dur = dur * 1.1_wp end do print * , \"We repeat the final chord and the final note\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ( 3 : 1 : - 1 )) call add_karplus_strong ( tape , track = 2 , t1 = t + dur , t2 = t + 5 * dur , f = fr ( name ) * SEMITONE ** MINOR_CHORD ( 3 ), Amp = 1.0_wp ) print * , \"Final fade out\" call apply_fade_out ( tape , track = 1 , t1 = t + dur , t2 = t + 5 * dur ) call apply_fade_out ( tape , track = 2 , t1 = t + dur , t2 = t + 5 * dur ) end associate print * , \"Final mix...\" ! In the mix, chords are rather on the left ! and plucked strings on the right (and their level is lowered): call demo % mix_tracks ( levels = [ 1._wp , 1.2_wp ], pan = [ - 0.5_wp , + 0.5_wp ]) call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program arpeggios","tags":"","loc":"program/arpeggios.html"},{"title":"shepard_scale – ForSynth","text":"Uses audio_effects wav_file_class forsynth program~~shepard_scale~~UsesGraph program~shepard_scale shepard_scale module~audio_effects audio_effects program~shepard_scale->module~audio_effects module~forsynth forsynth program~shepard_scale->module~forsynth module~wav_file_class wav_file_class program~shepard_scale->module~wav_file_class module~audio_effects->module~forsynth module~tape_recorder_class tape_recorder_class module~audio_effects->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A Shepard scale, giving the illusion of an ever increasing pitch in the first\nhalf of the tape and an ever decreasing pitch in the 2nd half.\nShepard, Roger N. \"Circularity in Judgments of Relative Pitch\",\nThe Journal of the Acoustical Society of America 36, no. 12,\n(December 1, 1964): 2346–53. https://doi.org/10.1121/1.1919362.\nhttps://en.wikipedia.org/wiki/Shepard_tone Calls program~~shepard_scale~~CallsGraph program~shepard_scale shepard_scale proc~apply_reverse_effect apply_reverse_effect program~shepard_scale->proc~apply_reverse_effect proc~close_wav_file WAV_file%close_WAV_file program~shepard_scale->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~shepard_scale->proc~create_wav_file proc~get_name WAV_file%get_name program~shepard_scale->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~shepard_scale->proc~mix_tracks proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=wp) :: Amp real(kind=wp) :: L real(kind=wp), parameter :: Lmax = 56._wp real(kind=wp), parameter :: Lmin = 22._wp integer :: c integer, parameter :: cmax = 12 real(kind=wp), parameter :: d = 0.125_wp type( WAV_file ) :: demo real(kind=wp), parameter :: ds = 0.840_wp real(kind=wp) :: f real(kind=wp), parameter :: fmin = 4.863_wp integer :: i integer :: k integer, parameter :: kmax = 9 real(kind=wp) :: omega integer :: t real(kind=wp) :: teta real(kind=wp) :: ti real(kind=wp) :: ti0 integer, parameter :: tmax = 12 Source Code program shepard_scale use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use audio_effects , only : apply_reverse_effect implicit none type ( WAV_file ) :: demo ! Time in seconds: real ( wp ) :: ti , ti0 ! Pulsation (radians/second): real ( wp ) :: omega real ( wp ) :: Amp integer :: i , k !-------------------------- ! Shepard scale parameters: !-------------------------- ! t th tone: integer :: t integer , parameter :: tmax = 12 ! Components of each tone: integer :: c ! The number of components was 10 in the paper, but the bandwidth was ! 5 kHz instead of 20 kHz. We have therefore added two octaves: integer , parameter :: cmax = 12 ! Sound pressure levels in dB for the components: real ( wp ) :: L real ( wp ), parameter :: Lmin = 2 2._wp real ( wp ), parameter :: Lmax = 5 6._wp ! Frequency of the lowest component of the first tone: real ( wp ), parameter :: fmin = 4.863_wp ! D# ! Duration of a tone and of the following silence: real ( wp ), parameter :: d = 0.125_wp real ( wp ), parameter :: ds = 0.840_wp real ( wp ) :: teta , f ! Number of repetitions: integer , parameter :: kmax = 9 print * , \"**** Creating shepard_scale.wav ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'shepard_scale.wav' , tracks = 1 , duration = 12 0._wp ) associate ( tape => demo % tape_recorder ) ! Repeat the Shepard scale: do k = 0 , kmax ! Tones loop: do t = 1 , tmax ! Components loop: do c = 1 , cmax ! Equations from the Shepard paper: f = fmin * 2._wp ** ((( c - 1 ) * tmax + t - 1 ) / real ( tmax , kind = wp )) omega = 2 * PI * f teta = ( 2 * PI * ( c - 1 ) * tmax + t - 1 ) / ( tmax * cmax ) L = Lmin + ( Lmax - Lmin ) * ( 1._wp - cos ( teta )) / 2._wp ! Converting dB to linear amplitude: Amp = 1 0._wp ** ( L / 2 0._wp ) ! Writing a sinusoidal signal at ti0, for a duration d. ! We do not write silences (the tape is initially silent). ti0 = k * tmax * ( d + ds ) + t * ( d + ds ) ti = ti0 do i = nint ( ti0 * RATE ), nint (( ti0 + d ) * RATE ) - 1 tape % left ( 1 , i ) = tape % left ( 1 , i ) + Amp * sin ( omega * ti ) ti = ti + dt end do end do end do end do tape % right = tape % left ! The 2nd half of the track is reversed to obtain an ever decreasing pitch: call apply_reverse_effect ( tape , track = 1 , t1 = ( 1 + kmax ) / 2 * tmax * ( d + ds ), t2 = ( 1 + kmax ) * tmax * ( d + ds ) + d ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program shepard_scale","tags":"","loc":"program/shepard_scale.html"},{"title":"shepard_risset_glissando – ForSynth","text":"Uses wav_file_class forsynth envelopes program~~shepard_risset_glissando~~UsesGraph program~shepard_risset_glissando shepard_risset_glissando module~envelopes envelopes program~shepard_risset_glissando->module~envelopes module~forsynth forsynth program~shepard_risset_glissando->module~forsynth module~wav_file_class wav_file_class program~shepard_risset_glissando->module~wav_file_class module~envelopes->module~forsynth module~tape_recorder_class tape_recorder_class module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A Shepard-Risset glissando, giving the illusion of an ever increasing pitch.\nIt is the continuous version of the Shepard scale.\nIt is not perfect, as we can hear that globally the whole is getting slowly\nhigher. It is also visible when zooming in the waveform woth audacity.\nSome kind of beating might occur due to the fact that in the sin(),\nboth omega and t are varying at each step. But as the f() are now redefined\nregularly, things are unclear for the moment...\nhttps://en.wikipedia.org/wiki/Shepard_tone Calls program~~shepard_risset_glissando~~CallsGraph program~shepard_risset_glissando shepard_risset_glissando proc~amplitude amplitude program~shepard_risset_glissando->proc~amplitude proc~apply_fade_in apply_fade_in program~shepard_risset_glissando->proc~apply_fade_in proc~apply_fade_out apply_fade_out program~shepard_risset_glissando->proc~apply_fade_out proc~close_wav_file WAV_file%close_WAV_file program~shepard_risset_glissando->proc~close_wav_file proc~create_wav_file WAV_file%create_WAV_file program~shepard_risset_glissando->proc~create_wav_file proc~get_name WAV_file%get_name program~shepard_risset_glissando->proc~get_name proc~initialize_frequencies initialize_frequencies program~shepard_risset_glissando->proc~initialize_frequencies proc~mix_tracks tape_recorder%mix_tracks program~shepard_risset_glissando->proc~mix_tracks proc~linear1 linear1 proc~amplitude->proc~linear1 proc~linear2 linear2 proc~amplitude->proc~linear2 proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=wp) :: Amp integer, parameter :: cmax = 10 real(kind=wp), parameter :: d = 16._wp type( WAV_file ) :: demo real(kind=wp) :: f (cmax) real(kind=wp), parameter :: fmax = fmin*2**cmax real(kind=wp), parameter :: fmin = 20._wp integer :: i real(kind=wp), parameter :: increase = 2**(+1/(d*RATE)) integer :: j real(kind=wp), parameter :: length = 120._wp real(kind=wp), parameter :: muf = ((log10(fmin)+log10(fmax))/2)-0.3 real(kind=wp) :: omega logical :: restart real(kind=wp), parameter :: sigma = 0.25_wp real(kind=wp) :: t Functions function amplitude (freq) Envelope of the glissando. A gaussian, plus linear sections at\nthe extremities, to reach the 0 level. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: freq Return Value real(kind=wp) function linear1 (freq, f1, f2) Returns an amplitude rising from 0 to 1, from f1 to f2. And 0 outside. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: freq real(kind=wp), intent(in) :: f1 real(kind=wp), intent(in) :: f2 Return Value real(kind=wp) function linear2 (freq, f1, f2) Returns an amplitude falling from 1 to 0, from f1 to f2. And 0 outside. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: freq real(kind=wp), intent(in) :: f1 real(kind=wp), intent(in) :: f2 Return Value real(kind=wp) Subroutines subroutine initialize_frequencies () Arguments None subroutine write_amplitude_envelope () Useful for debugging and setting the envelope parameters: Arguments None Source Code program shepard_risset_glissando use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use envelopes , only : apply_fade_in , apply_fade_out implicit none type ( WAV_file ) :: demo ! Pulsation (radians/second): real ( wp ) :: omega real ( wp ) :: t real ( wp ) :: Amp integer :: i , j !-------------------------- ! Glissando parameters: !-------------------------- ! Bandwidth 20-20480 Hz: 10 octaves integer , parameter :: cmax = 10 real ( wp ), parameter :: fmin = 2 0._wp real ( wp ), parameter :: fmax = fmin * 2 ** cmax ! Frequencies of each component: real ( wp ) :: f ( cmax ) ! Gaussian window, central frequency in log scale, with a shift: real ( wp ), parameter :: muf = (( log10 ( fmin ) + log10 ( fmax )) / 2 ) - 0.3 ! Standard deviation (very important for a good result): real ( wp ), parameter :: sigma = 0.25_wp ! Total duration of the WAV: real ( wp ), parameter :: length = 12 0._wp ! Setting the increase rate: real ( wp ), parameter :: d = 1 6._wp real ( wp ), parameter :: increase = 2 ** ( + 1 / ( d * RATE )) logical :: restart ! Useful for debugging and setting the envelope parameters: !call write_amplitude_envelope() ! Initializing the components, separated by octaves: call initialize_frequencies () print * , \"Frequencies:\" , f print * , \"Log Central frequency:\" , muf print * , \"Pitch increase:\" , increase print * , \"**** Creating shepard_risset_glissando.wav ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'shepard_risset_glissando.wav' , tracks = 1 , duration = length ) associate ( tape => demo % tape_recorder ) do i = 0 , nint ( length * RATE ) - 1 t = i * dt ! Computing and adding each component on the track: do j = 1 , cmax omega = 2 * PI * f ( j ) ! Amplitude of the signal (gaussian distribution): Amp = amplitude ( f ( j )) tape % left ( 1 , i ) = tape % left ( 1 , i ) + Amp * sin ( omega * t ) end do ! Increasing pitch of each component: f = f * increase restart = . false . ! Each component must stay between fmin and fmax: if ( maxval ( f ) >= fmax ) restart = . true . ! Would be useful for a decreasing glissando: if ( minval ( f ) <= fmin ) restart = . true . ! As each component is separated by one octave, we can ! redefine all the components as they were at t=0, each time one has ! passed the last octave. In that way, we are sure they won't diverge ! at all due to numerical problems: if ( restart ) then call initialize_frequencies end if end do tape % right = tape % left call apply_fade_in ( tape , track = 1 , t1 = 0._wp , t2 = 1._wp ) call apply_fade_out ( tape , track = 1 , t1 = length - 1 , t2 = length ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () contains subroutine initialize_frequencies () integer :: j do j = 1 , cmax f ( j ) = fmin * 2 ** ( j - 1 ) end do end subroutine !> Returns an amplitude rising from 0 to 1, from f1 to f2. And 0 outside. real ( wp ) function linear1 ( freq , f1 , f2 ) real ( wp ), intent ( in ) :: freq , f1 , f2 if (( f1 <= freq ). and .( freq <= f2 )) then linear1 = ( freq - f1 ) / ( f2 - f1 ) else linear1 = 0 end if end function !> Returns an amplitude falling from 1 to 0, from f1 to f2. And 0 outside. real ( wp ) function linear2 ( freq , f1 , f2 ) real ( wp ), intent ( in ) :: freq , f1 , f2 if (( f1 <= freq ). and .( freq <= f2 )) then linear2 = ( freq - f2 ) / ( f1 - f2 ) else linear2 = 0 end if end function !> Envelope of the glissando. A gaussian, plus linear sections at !> the extremities, to reach the 0 level. real ( wp ) function amplitude ( freq ) real ( wp ), intent ( in ) :: freq real ( wp ) :: Amp if ( freq <= 2 * fmin ) then Amp = linear1 ( freq , fmin , 2 * fmin ) else if ( freq >= fmax / 2 ) then Amp = linear2 ( freq , fmax / 2 , fmax ) else Amp = 1 end if amplitude = Amp * ( 1 / ( sqrt ( 2 * PI ) * sigma )) * exp ( - ( log10 ( freq ) - muf ) ** 2 / ( 2 * sigma ** 2 )) end function !> Useful for debugging and setting the envelope parameters: subroutine write_amplitude_envelope () real ( wp ) :: freq integer :: u integer , parameter :: points = 500 print * , muf , \" muf = \" , 10 ** muf open ( newunit = u , file = \"glissando_envelope.txt\" , status = 'replace' , action = 'write' ) do i = 1 , points freq = fmin + i * ( fmax - fmin ) / points write ( u , * ) freq , amplitude ( freq ) end do close ( u ) end subroutine end program shepard_risset_glissando","tags":"","loc":"program/shepard_risset_glissando.html"},{"title":"chords_and_melody – ForSynth","text":"Uses music_common audio_effects signals forsynth music wav_file_class envelopes program~~chords_and_melody~~UsesGraph program~chords_and_melody chords_and_melody module~audio_effects audio_effects program~chords_and_melody->module~audio_effects module~envelopes envelopes program~chords_and_melody->module~envelopes module~forsynth forsynth program~chords_and_melody->module~forsynth module~music music program~chords_and_melody->module~music module~music_common music_common program~chords_and_melody->module~music_common module~signals signals program~chords_and_melody->module~signals module~wav_file_class wav_file_class program~chords_and_melody->module~wav_file_class module~audio_effects->module~forsynth module~tape_recorder_class tape_recorder_class module~audio_effects->module~tape_recorder_class module~envelopes->module~forsynth module~envelopes->module~tape_recorder_class iso_fortran_env iso_fortran_env module~forsynth->iso_fortran_env module~music->module~envelopes module~music->module~forsynth module~music->module~music_common module~music->module~signals module~music->module~tape_recorder_class module~signals->module~envelopes module~signals->module~forsynth module~signals->module~tape_recorder_class module~wav_file_class->module~forsynth module~wav_file_class->iso_fortran_env module~wav_file_class->module~tape_recorder_class module~tape_recorder_class->module~forsynth Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A sequence of synth chords is repeated, and the corresponding notes are played\nrandomly by plucked strings. Calls program~~chords_and_melody~~CallsGraph program~chords_and_melody chords_and_melody proc~add_chord add_chord program~chords_and_melody->proc~add_chord proc~add_karplus_strong add_karplus_strong program~chords_and_melody->proc~add_karplus_strong proc~adsr_new ADSR_envelope%ADSR_new program~chords_and_melody->proc~adsr_new proc~apply_delay_effect apply_delay_effect program~chords_and_melody->proc~apply_delay_effect proc~close_wav_file WAV_file%close_WAV_file program~chords_and_melody->proc~close_wav_file proc~copy_section tape_recorder%copy_section program~chords_and_melody->proc~copy_section proc~create_wav_file WAV_file%create_WAV_file program~chords_and_melody->proc~create_wav_file proc~fr fr program~chords_and_melody->proc~fr proc~get_name WAV_file%get_name program~chords_and_melody->proc~get_name proc~mix_tracks tape_recorder%mix_tracks program~chords_and_melody->proc~mix_tracks proc~add_note add_note proc~add_chord->proc~add_note proc~finalize tape_recorder%finalize proc~close_wav_file->proc~finalize proc~write_normalized_data WAV_file%write_normalized_data proc~close_wav_file->proc~write_normalized_data proc~new tape_recorder%new proc~create_wav_file->proc~new proc~write_header WAV_file%write_header proc~create_wav_file->proc~write_header proc~add_sine_wave add_sine_wave proc~add_note->proc~add_sine_wave proc~clear_tracks tape_recorder%clear_tracks proc~new->proc~clear_tracks proc~adsr_level ADSR_envelope%ADSR_level proc~add_sine_wave->proc~adsr_level Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=wp) :: chosen_note (0:3) type( WAV_file ) :: demo real(kind=wp) :: dnote type( ADSR_envelope ) :: env integer :: i real(kind=wp) :: r real(kind=wp) :: t Source Code program chords_and_melody use forsynth , only : wp use wav_file_class , only : WAV_file use signals , only : add_karplus_strong use music_common , only : MINOR_CHORD , MAJOR_CHORD use music , only : add_chord , fr use audio_effects , only : apply_delay_effect use envelopes , only : ADSR_envelope implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env integer :: i real ( wp ) :: t , dnote , r real ( wp ) :: chosen_note ( 0 : 3 ) print * , \"**** Demo chords and melody ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'chords_and_melody.wav' , tracks = 2 , duration = 12 0._wp ) ! We create an ADSR envelope that will be passed to signals (add_chord): call env % new ( A = 1 5._wp , D = 4 0._wp , S = 8 0._wp , R = 1 5._wp ) ! Notes duration in seconds: dnote = 3.0_wp associate ( tape => demo % tape_recorder ) print * , \"Track 1: repeating Am C G Dm chords...\" t = 0.0_wp call add_chord ( tape , track = 1 , t1 = t , t2 = t + dnote , f = fr ( \"A3\" ), Amp = 1.0_wp , chord = MINOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + dnote , t2 = t + 2 * dnote , f = fr ( \"C3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 2 * dnote , t2 = t + 3 * dnote , f = fr ( \"G3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 3 * dnote , t2 = t + 4 * dnote , f = fr ( \"D3\" ), Amp = 1.0_wp , chord = MINOR_CHORD , envelope = env ) ! Repeat those four chords until the end of the track: do i = 1 , 9 call demo % copy_section ( from_track = 1 , to_track = 1 , t1 = t , t2 = t + 4 * dnote , t3 = 4 * dnote * i ) end do print * , \"Track 2: playing random A C G D notes using plucked strings...\" dnote = dnote / 4 ! An array of notes that can be played: chosen_note ( 0 ) = fr ( \"A3\" ) chosen_note ( 1 ) = fr ( \"C3\" ) chosen_note ( 2 ) = fr ( \"G3\" ) chosen_note ( 3 ) = fr ( \"D3\" ) do i = 0 , 9 * 16 t = dnote * i call random_number ( r ) call add_karplus_strong ( tape , track = 2 , t1 = t , t2 = t + dnote , f = chosen_note ( int ( r * 4 )), Amp = 1._wp ) end do ! A double delay inspired by The Edge. ! Dotted quavers delay: call apply_delay_effect ( tape , track = 2 , t1 = 0.0_wp , t2 = demo % duration , delay = dnote * 0.75_wp , Amp = 0.45_wp ) ! Plus a quavers delay: call apply_delay_effect ( tape , track = 2 , t1 = 0.0_wp , t2 = demo % duration , delay = dnote * 0.50_wp , Amp = 0.30_wp ) end associate print * , \"Final mix...\" ! In the mix, chords are rather on the left ! and plucked strings on the right (and their level is lowered): call demo % mix_tracks ( levels = [ 1._wp , 0.75_wp ], pan = [ - 0.5_wp , + 0.5_wp ]) call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program chords_and_melody","tags":"","loc":"program/chords_and_melody.html"},{"title":"multiplication_bells.f90 – ForSynth","text":"This file depends on sourcefile~~multiplication_bells.f90~~EfferentGraph sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~multiplication_bells.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 sourcefile~signals.f90 signals.f90 sourcefile~multiplication_bells.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~multiplication_bells.f90->sourcefile~wav_file_class.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2025-02-05 ! Last modifications: 2025-02-13 !> An example with a lot of bells, either periodic or random. !> https://en.wikipedia.org/wiki/Campanology program multiplication_bells use forsynth , only : wp use wav_file_class , only : WAV_file , tape_recorder use music , only : SEMITONE , PITCH use signals , only : add_bell implicit none type ( WAV_file ) :: demo ! Total duration in seconds: real ( wp ), parameter :: t2 = 7 5._wp ! Duration of the basic note: real ( wp ), parameter :: dnote = 3._wp ! Semitones for major third, fifth, 7th, octave, major third, fifth: integer , parameter :: shift ( 0 : 5 ) = [ 4 , 7 , 10 , 12 , 16 , 19 ] integer , parameter :: iend = 15 ! Nb of periods for the periodic bells integer :: i ! Loop counter real ( wp ) :: r1 , r2 , r3 ! Random numbers ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'multiplication_bells.wav' , tracks = 1 , duration = t2 ) print * , \"**** Creating \" // demo % get_name () // \" ****\" print * , \"Be patient, it may take up to one minute...\" associate ( tape => demo % tape_recorder ) ! Intro: call add_bell ( tape , track = 1 , t1 = 0._wp , f = PITCH * SEMITONE ** ( - 7 ), Amp = 2._wp ) ! Periodic bells: do i = 1 , iend call add_bell ( tape , track = 1 , t1 = i * dnote , f = PITCH * SEMITONE ** ( - 4 ), Amp = 1._wp ) call add_bell ( tape , track = 1 , t1 = i * dnote + dnote / 4 , f = PITCH * SEMITONE ** ( 0 ) , Amp = 1._wp ) call add_bell ( tape , track = 1 , t1 = i * dnote + 3 * dnote / 4 , f = PITCH * SEMITONE ** ( 0 ) , Amp = 1._wp ) end do ! Random bells: do i = 1 , 100 call random_number ( r1 ) ! Starting time call random_number ( r2 ) ! Tone call random_number ( r3 ) ! Amplitude call add_bell ( tape , track = 1 , t1 = 4._wp + ( iend - 2 ) * dnote * r1 , f = PITCH * SEMITONE ** ( shift ( int ( r2 * 6 ))), Amp = 1._wp * r3 ) end do ! Outro: call add_bell ( tape , track = 1 , t1 = ( iend + 2 ) * dnote , f = PITCH * SEMITONE ** ( - 7 ), Amp = 2._wp ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program multiplication_bells","tags":"","loc":"sourcefile/multiplication_bells.f90.html"},{"title":"drone_music.f90 – ForSynth","text":"This file depends on sourcefile~~drone_music.f90~~EfferentGraph sourcefile~drone_music.f90 drone_music.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~drone_music.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~drone_music.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~drone_music.f90->sourcefile~wav_file_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-19 ! Last modifications: 2024-05-31 !> Experimental drone music. program drone_music use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use music , only : SEMITONE use envelopes , only : apply_fade_in , apply_fade_out implicit none type ( WAV_file ) :: demo ! Time in seconds: real ( wp ) :: t , t1 , t2 , f0 , f1 , f2 ! Pulsation (radians/second): real ( wp ) :: omega1 , omega2 , omegaLFO1 , omegaLFO2 real ( wp ) :: Amp integer :: i ! Fundamental frequency: f0 = 8 0._wp ! Low Frequency Oscillators: omegaLFO1 = 2 * PI * 0.03_wp omegaLFO2 = 2 * PI * 0.001_wp Amp = 1._wp print * , \"**** Creating drone_music.wav ****\" t1 = 0._wp t2 = 18 0._wp ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'drone_music.wav' , tracks = 1 , duration = t2 ) associate ( tape => demo % tape_recorder ) t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 ! Fundamental: f1 = f0 * ( 1 + 0.01_wp * sin ( omegaLFO1 * t )) omega1 = 2 * PI * f1 tape % left ( 1 , i ) = Amp * sin ( omega1 * t ) ! Perfect fifth (7 semitones higher): f2 = f0 * ( SEMITONE ** 7 ) * ( 1 + 0.01_wp * sin ( omegaLFO2 * t )) omega2 = 2 * PI * f2 tape % left ( 1 , i ) = tape % left ( 1 , i ) + Amp * sin ( omega2 * t ) tape % right ( 1 , i ) = tape % left ( 1 , i ) t = t + dt end do call apply_fade_in ( tape , track = 1 , t1 = 0._wp , t2 = 3._wp ) call apply_fade_out ( tape , track = 1 , t1 = t2 - 3 , t2 = t2 ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program drone_music","tags":"","loc":"sourcefile/drone_music.f90.html"},{"title":"misc_sounds.f90 – ForSynth","text":"This file depends on sourcefile~~misc_sounds.f90~~EfferentGraph sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~misc_sounds.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~misc_sounds.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~misc_sounds.f90->sourcefile~wav_file_class.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-04-29 ! Last modifications: 2024-05-31 !> Miscellaneous signals, especially obtained by frequency or phase modulation. !> A WAV file is created for each sound. program misc_sounds use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use tape_recorder_class use music , only : fr implicit none type ( WAV_file ) :: demo integer :: i character ( 2 ) :: number print * , \"**** Creating misc_sounds WAV files ****\" do i = 0 , 23 print * , i write ( number , '(I0)' ) i ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'misc_sounds' // trim ( number ) // '.wav' , tracks = 1 , duration = 3 0._wp ) ! We call the subroutine for signal i: call add_misc_signal ( demo % tape_recorder , track = 1 , t1 = 0._wp , t2 = 3 0._wp , f = fr ( \"A4\" ), Amp = 1._wp , choice = i ) ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () end do print * , \"You can now play the file \" , demo % get_name () contains !> Add on the track a signal choosen by its number: subroutine add_misc_signal ( tape , track , t1 , t2 , f , Amp , choice ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , choice real ( wp ), intent ( in ) :: t1 , t2 , f , Amp ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t real ( wp ), parameter :: phi = - 3 * PI ! Phase in radians at t=0 integer :: i , j omega = 2 * PI * f t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 select case ( choice ) case ( 0 ) ! Pure sinus tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) case ( 1 ) ! Science fiction signal... tape % left ( track , i ) = + Amp * sin ( omega * t + phi * cos ( 75 * t ) / ( 1 + log ( t / 100 + 0.01_wp ))) case ( 2 ) ! Hummmmmmmmmm... tape % left ( track , i ) = + Amp * sin ( omega * t + phi * sin ( omega * 0.2_wp * t )) case ( 3 ) ! UFO or siren? tape % left ( track , i ) = + Amp * sin ( omega * t + phi * cos ( 25 * t )) case ( 4 ) ! Noisy science fiction tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( t * 50 )) * t + phi ) case ( 5 ) ! Whistling, slower and slower... tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( sqrt ( t ) * 50 )) * t + phi ) case ( 6 ) ! Similar tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.2_wp * sin ( log ( t ) * 50 )) * t + phi ) case ( 7 ) ! Dudududududu... tape % left ( track , i ) = + Amp * sin ( t * 30 ) * sin ( omega * t + phi ) case ( 8 ) ! Duuuuuuuuuuuuuuuuuuu tape % left ( track , i ) = + Amp * sin ( omega * t + phi * ( 0.5_wp + 0.5_wp * sin ( t * 500 ))) case ( 9 ) ! A higher duuuuuuuuuuuuuuuuuuu tape % left ( track , i ) = + Amp / 2 * sin ( omega * t + phi ) + Amp / 2 * sin ( omega * 1.1892_wp * t + phi ) case ( 10 ) ! Higher and higher... tape % left ( track , i ) = + Amp * sin (( omega * ( 1 + t / 10 )) * t + phi ) case ( 11 ) ! Dampening slowly do j = 1 , 7 tape % left ( track , i ) = + Amp / ( j * ( 1 + t ** j )) * sin ( j * omega * t ) end do case ( 12 ) ! Vibrato tape % left ( track , i ) = + Amp * sin ( omega * t + phi * ( 1._wp + 0.5_wp * sin ( 2 * PI * 4 * t ))) case ( 13 ) ! A mix tape % left ( track , i ) = + Amp * sin ( t ) * sin ( omega * t + phi ) & & + Amp * cos ( 2.5_wp * t ) * sin ( 1.5_wp * omega * t + phi ) + Amp * sin ( 3 * t ) * sin ( 2 * omega * t + phi ) case ( 14 ) ! Tremolo tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) + Amp * sin ( 1.001_wp * omega * t + phi ) & & + Amp * sin ( 0.999_wp * omega * t + phi ) case ( 15 ) ! Poke... (a short percussion based on the Sinc function) if ( omega * t + phi /= 0._wp ) then tape % left ( track , i ) = + Amp * sin ( omega * t + phi ) / ( omega * t + phi ) else tape % left ( track , i ) = + Amp end if case ( 16 ) ! Science fiction, becoming higher and noisy tape % left ( track , i ) = + Amp * sin ( omega * ( 1._wp + 0.001_wp * sin ( t * 500 )) * t + phi ) case ( 17 ) ! Dissonant tape % left ( track , i ) = + Amp * sin ( omega * t + 4 * sin ( omega / 10 * t )) case ( 18 ) ! Dampening tape % left ( track , i ) = + Amp * ( 1 / ( 1 + t ** 3 )) * sin ( omega * t + 2 * sin ( omega * t + 3 * sin ( omega * t ))) case ( 19 ) ! Science-fiction, becoming higher and noisy tape % left ( track , i ) = + Amp * & & sin ( omega * ( 1._wp + 0.001_wp * sin ( t * 500 * ( 1._wp + 0.0002_wp * cos ( t * 50 )))) * t + phi ) case ( 20 ) ! Another dampening sound tape % left ( track , i ) = + Amp * ( exp ( - t ) * sin ( omega * t ) + 0.5_wp * exp ( - t ** 2 ) * sin ( 2 * omega * t ) & & + 0.25_wp * exp ( - t ** 3 ) * sin ( 3 * omega * t ) + 0.12_wp * exp ( - t ** 4 ) * sin ( 4 * omega * t )) case ( 21 ) ! Dampening slowly do j = 1 , 14 tape % left ( track , i ) = + Amp / ( j ** 2 * ( 1 + t ** j )) * sin ( j * omega * t ) end do case ( 22 ) ! Clarinet do j = 1 , 11 , + 2 tape % left ( track , i ) = + Amp / j ** 0.7_wp * sin ( j * omega * t ) end do case ( 23 ) ! Bessel function of the first kind J1: pong... tape % left ( track , i ) = + Amp * bessel_jn ( 1 , omega * t ) case ( 24 ) ! Bessel functions of the first kind: ping (far shorter) tape % left ( track , i ) = + Amp * bessel_jn ( 1 , omega * t ) * bessel_jn ( 2 , omega * t ) end select tape % right ( track , i ) = tape % left ( track , i ) t = t + dt end do end subroutine add_misc_signal end program misc_sounds","tags":"","loc":"sourcefile/misc_sounds.f90.html"},{"title":"forsynth.f90 – ForSynth","text":"Files dependent on this one sourcefile~~forsynth.f90~~AfferentGraph sourcefile~forsynth.f90 forsynth.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~all_signals.f90->sourcefile~envelopes.f90 sourcefile~music.f90 music.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~signals.f90 signals.f90 sourcefile~all_signals.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~all_signals.f90->sourcefile~wav_file_class.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~forsynth.f90 sourcefile~arpeggios.f90->sourcefile~envelopes.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~arpeggios.f90->sourcefile~signals.f90 sourcefile~arpeggios.f90->sourcefile~wav_file_class.f90 sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~audio_effects.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~forsynth.f90 sourcefile~blues.f90->sourcefile~audio_effects.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~blues.f90->sourcefile~signals.f90 sourcefile~blues.f90->sourcefile~wav_file_class.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~forsynth.f90 sourcefile~chords_and_melody.f90->sourcefile~audio_effects.f90 sourcefile~chords_and_melody.f90->sourcefile~envelopes.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~chords_and_melody.f90->sourcefile~signals.f90 sourcefile~chords_and_melody.f90->sourcefile~wav_file_class.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~forsynth.f90 sourcefile~demo_effects.f90->sourcefile~audio_effects.f90 sourcefile~demo_effects.f90->sourcefile~envelopes.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~demo_effects.f90->sourcefile~wav_file_class.f90 sourcefile~doppler_effect.f90 doppler_effect.f90 sourcefile~doppler_effect.f90->sourcefile~forsynth.f90 sourcefile~doppler_effect.f90->sourcefile~wav_file_class.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~forsynth.f90 sourcefile~drone_music.f90->sourcefile~envelopes.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~drone_music.f90->sourcefile~wav_file_class.f90 sourcefile~drum_machine.f90 drum_machine.f90 sourcefile~drum_machine.f90->sourcefile~forsynth.f90 sourcefile~drum_machine.f90->sourcefile~signals.f90 sourcefile~drum_machine.f90->sourcefile~wav_file_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~forsynth.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~misc_sounds.f90->sourcefile~tape_recorder_class.f90 sourcefile~misc_sounds.f90->sourcefile~wav_file_class.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~forsynth.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 sourcefile~multiplication_bells.f90->sourcefile~signals.f90 sourcefile~multiplication_bells.f90->sourcefile~wav_file_class.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~forsynth.f90 sourcefile~radioactivity.f90->sourcefile~envelopes.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 sourcefile~radioactivity.f90->sourcefile~tape_recorder_class.f90 sourcefile~radioactivity.f90->sourcefile~wav_file_class.f90 sourcefile~morse_code.f90 morse_code.f90 sourcefile~radioactivity.f90->sourcefile~morse_code.f90 sourcefile~shepard_risset_glissando.f90 shepard_risset_glissando.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~forsynth.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~envelopes.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~wav_file_class.f90 sourcefile~shepard_scale.f90 shepard_scale.f90 sourcefile~shepard_scale.f90->sourcefile~forsynth.f90 sourcefile~shepard_scale.f90->sourcefile~audio_effects.f90 sourcefile~shepard_scale.f90->sourcefile~wav_file_class.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~morse_code.f90->sourcefile~signals.f90 sourcefile~morse_code.f90->sourcefile~tape_recorder_class.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-07-14 !> This module contains a few parameters, especially the sampling frequency and !> the temporal step. module forsynth use , intrinsic :: iso_fortran_env , only : INT16 , INT32 , INT64 , REAL32 , REAL64 implicit none private !> The default working precision wp is REAL64. !> REAL32 can be set: it will accelerate computations and give good results !> most of the time. But in certain situations, for example drone music, it !> can introduce artefacts. integer , parameter :: wp = REAL64 real ( wp ), parameter :: PI = 4.0_wp * atan ( 1.0_wp ) ! Sampling frequency and temporal step: integer , parameter :: RATE = 44100 real ( wp ), parameter :: dt = 1.0_wp / RATE public :: wp , test_the_machine , PI , RATE , dt contains !> A WAV file contains 64, 32 and 16 bits data or metadata, !> so we need those kinds. subroutine test_the_machine if (( INT16 < 0 ) . or . ( INT32 < 0 ) . or . ( INT64 < 0 )) then print * , \"Some INT types are not supported!\" print * , \"INT16: \" , INT16 print * , \"INT32: \" , INT32 print * , \"INT64: \" , INT64 error stop 1 end if end subroutine end module forsynth","tags":"","loc":"sourcefile/forsynth.f90.html"},{"title":"blues.f90 – ForSynth","text":"This file depends on sourcefile~~blues.f90~~EfferentGraph sourcefile~blues.f90 blues.f90 sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~blues.f90->sourcefile~audio_effects.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~blues.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~blues.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~blues.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~blues.f90->sourcefile~wav_file_class.f90 sourcefile~audio_effects.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-02 !> A random walk on a blues scale. program blues use forsynth , only : wp use wav_file_class , only : WAV_file use signals , only : add_karplus_strong use music , only : fr use music_common , only : HEXATONIC_BLUES_SCALE use audio_effects , only : apply_tremolo_effect implicit none type ( WAV_file ) :: demo real ( wp ) :: t , dnote real ( wp ) :: r ! Random number integer :: i , k print * , \"**** Demo Blues ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'blues.wav' , tracks = 1 , duration = 3 5._wp ) associate ( tape => demo % tape_recorder ) ! Notes duration in seconds: dnote = 0.5_wp t = 0.0_wp print * , \"A blues scale\" t = t + dnote do i = 1 , 6 call add_karplus_strong ( tape , track = 1 , t1 = t , t2 = t + dnote , & & f = fr ( trim ( HEXATONIC_BLUES_SCALE ( i )) // '3' ), Amp = 1.0_wp ) t = t + dnote end do print * , \"Random walk on that blues scale\" k = 1 do i = 1 , 60 call random_number ( r ) if ( r < 0.5_wp ) then k = k - 1 else k = k + 1 end if if ( k < 1 ) k = 1 if ( k > 6 ) k = 6 call random_number ( r ) r = min ( 1.0_wp , r + 0.25_wp ) call add_karplus_strong ( tape , track = 1 , t1 = t , t2 = t + dnote * ( r + 0.25_wp ), & & f = fr ( trim ( HEXATONIC_BLUES_SCALE ( k )) // '2' ), Amp = 1.0_wp ) t = t + dnote * ( r + 0.25_wp ) end do ! A tremolo at 3 Hz and an amplitude of 0.2: call apply_tremolo_effect ( tape , track = 1 , t1 = 0.0_wp , t2 = t , f = 3.0_wp , AmpLFO = 0.2_wp ) end associate print * , \"Final mix...\" ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program blues","tags":"","loc":"sourcefile/blues.f90.html"},{"title":"music_common.f90 – ForSynth","text":"Files dependent on this one sourcefile~~music_common.f90~~AfferentGraph sourcefile~music_common.f90 music_common.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~music_common.f90 sourcefile~music.f90 music.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~music_common.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~music_common.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~music_common.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~music_common.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! ForMIDI: a small Fortran MIDI sequencer for composing music, exploring !          algorithmic music and music theory ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-09 ! Last modifications: 2024-05-09 !>--------------------------------------------------------------------------- !> Contains music theory elements: scales, circle of fifths, chords, etc. !> !> This file will be kept identical in the ForMIDI and ForSynth projects. !> It could be put in a separate fpm repository and used as a dependency, !> but for the time being, synchronizing it by hand is sufficient. !>--------------------------------------------------------------------------- module music_common implicit none public !> We define some scales, excluding the octave of the first note. !> Always use the trim() function to remove trailing spaces. !> https://en.wikipedia.org/wiki/Scale_(music) character ( 2 ), dimension ( 1 : 12 ), parameter :: CHROMATIC_SCALE = & & [ 'C ' , 'C#' , 'D ' , 'D#' , 'E ' , 'F ' , 'F#' , 'G ' , 'G#' , 'A ' , 'A#' , 'B ' ] !> https://en.wikipedia.org/wiki/Major_scale character ( 1 ), dimension ( 1 : 7 ), parameter :: MAJOR_SCALE = & & [ 'C' , 'D' , 'E' , 'F' , 'G' , 'A' , 'B' ] !> https://en.wikipedia.org/wiki/Minor_scale#Harmonic_minor_scale character ( 2 ), dimension ( 1 : 7 ), parameter :: HARMONIC_MINOR_SCALE = & & [ 'A ' , 'B ' , 'C ' , 'D ' , 'E ' , 'F ' , 'G#' ] !> https://en.wikipedia.org/wiki/Pentatonic_scale#Major_pentatonic_scale character ( 1 ), dimension ( 1 : 5 ), parameter :: MAJOR_PENTATONIC_SCALE = & & [ 'C' , 'D' , 'E' , 'G' , 'A' ] !> https://en.wikipedia.org/wiki/Hexatonic_scale#Blues_scale character ( 2 ), dimension ( 1 : 6 ), parameter :: HEXATONIC_BLUES_SCALE = & & [ 'C ' , 'Eb' , 'F ' , 'Gb' , 'G ' , 'Bb' ] !> https://en.wikipedia.org/wiki/Whole_tone_scale character ( 2 ), dimension ( 1 : 6 ), parameter :: WHOLE_TONE_SCALE = & & [ 'C ' , 'D ' , 'E ' , 'F#' , 'G#' , 'A#' ] !> https://en.wikipedia.org/wiki/Circle_of_fifths !> Always use the trim() function to remove trailing spaces. character ( 2 ), dimension ( 1 : 12 ) :: CIRCLE_OF_FIFTHS_MAJOR = & & [ 'C ' , 'G ' , 'D ' , 'A ' , 'E ' , 'B ' , 'Gb' , 'Db' , 'Ab' , 'Eb' , 'Bb' , 'F ' ] character ( 2 ), dimension ( 1 : 12 ) :: CIRCLE_OF_FIFTHS_MINOR = & & [ 'A ' , 'E ' , 'B ' , 'F#' , 'C#' , 'G#' , 'Eb' , 'Bb' , 'F ' , 'C ' , 'G ' , 'D ' ] !> Some frequent chords. !> These arrays can be passed to the write_chord() subroutine. !> https://en.wikipedia.org/wiki/Chord_(music) integer , parameter :: MAJOR_CHORD ( 1 : 3 ) = [ 0 , 4 , 7 ] integer , parameter :: MINOR_CHORD ( 1 : 3 ) = [ 0 , 3 , 7 ] integer , parameter :: DOMINANT_7TH_CHORD ( 1 : 4 ) = [ 0 , 4 , 7 , 10 ] integer , parameter :: SUS2_CHORD ( 1 : 3 ) = [ 0 , 2 , 7 ] integer , parameter :: SUS4_CHORD ( 1 : 3 ) = [ 0 , 5 , 7 ] integer , parameter :: POWER_CHORD ( 1 : 3 ) = [ 0 , 7 , 12 ] integer , private :: j ! Needed for the following implied do loop: integer , parameter :: CLUSTER_CHORD ( 1 : 12 ) = [( j , j = 0 , 11 )] contains end module music_common","tags":"","loc":"sourcefile/music_common.f90.html"},{"title":"signals.f90 – ForSynth","text":"This file depends on sourcefile~~signals.f90~~EfferentGraph sourcefile~signals.f90 signals.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~signals.f90~~AfferentGraph sourcefile~signals.f90 signals.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~signals.f90 sourcefile~music.f90 music.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~signals.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~signals.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~signals.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~drum_machine.f90 drum_machine.f90 sourcefile~drum_machine.f90->sourcefile~signals.f90 sourcefile~morse_code.f90 morse_code.f90 sourcefile~morse_code.f90->sourcefile~signals.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~signals.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~morse_code.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2025-02-12 !> Subroutines generating different kind of signals module signals use forsynth , only : wp , RATE , dt , PI use envelopes , only : ADSR_envelope , fit_exp use tape_recorder_class implicit none private public :: add_sine_wave , add_square_wave , add_sawtooth_wave ,& & add_triangle_wave , add_karplus_strong , add_karplus_strong_stretched , & & add_karplus_strong_drum , add_karplus_strong_drum_stretched , & & add_noise , weierstrass , add_weierstrass , add_bell contains !> Adds on the track a sine wave with an ADSR envelope: subroutine add_sine_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Phase at t=0 s, radians: real ( wp ), parameter :: phi = 0.0_wp ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: signal integer :: i env = 1._wp ! Default value if no envelope is passed omega = 2.0_wp * PI * f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) signal = Amp * sin ( omega * t + phi ) * env tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_sine_wave !> Adds on the track a square wave with an ADSR envelope: subroutine add_square_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Period in seconds: real ( wp ) :: tau ! Time in seconds: real ( wp ) :: t real ( wp ) :: signal ! ADSR Envelope value: real ( wp ) :: env integer :: i , n env = 1._wp ! Default value if no envelope is passed tau = 1.0_wp / f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) ! Number of the half-period: n = int ( t / ( tau / 2.0_wp )) ! If n is even, signal is +Amp, if odd -Amp: if ( mod ( n , 2 ) == 0 ) then signal = + Amp * env else signal = - Amp * env end if tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_square_wave !> Adds on the track a sawtooth wave with an ADSR envelope: subroutine add_sawtooth_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Period in seconds: real ( wp ) :: tau ! Time in seconds: real ( wp ) :: t real ( wp ) :: signal ! ADSR Envelope value: real ( wp ) :: env integer :: i env = 1._wp ! Default value if no envelope is passed tau = 1.0_wp / f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) ! We substract 0.5 for the signal to be centered on 0: signal = 2 * ((( t / tau ) - floor ( t / tau )) - 0.5_wp ) * Amp * env tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_sawtooth_wave !> Adds on the track a triangle wave with an ADSR envelope: subroutine add_triangle_wave ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Period in seconds: real ( wp ) :: tau ! Time in seconds: real ( wp ) :: t real ( wp ) :: signal ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: a , x integer :: i , n env = 1._wp ! Default value if no envelope is passed tau = 1.0_wp / f a = ( 2.0_wp * Amp ) / ( tau / 2.0_wp ) do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) ! Number of the half-period: n = int ( t / ( tau / 2.0_wp )) ! Is n even or odd ? if ( mod ( n , 2 ) == 0 ) then x = t - n * ( tau / 2.0_wp ) ; signal = a * x - Amp else x = t - n * ( tau / 2.0_wp ) + tau / 2.0_wp ; signal = - a * x + 3.0_wp * Amp end if tape % left ( track , i ) = tape % left ( track , i ) + signal * env tape % right ( track , i ) = tape % right ( track , i ) + signal * env end do end subroutine add_triangle_wave !> Karplus and Strong algorithm (1983), for plucked-string !> http://crypto.stanford.edu/~blynn/sound/karplusstrong.html !> https://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis subroutine add_karplus_strong ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp real ( wp ) :: signal , r integer :: i , P integer :: i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 P = nint ( RATE / f ) - 2 ! Initial noise: do i = i1 , i1 + P ! 0 <= r < 1 call random_number ( r ) ! -Amp <= signal < +Amp signal = Amp * ( 2.0_wp * r - 1.0_wp ) ! Track 0 is used as an auxiliary track: tape % left ( 0 , i ) = signal tape % right ( 0 , i ) = signal end do ! Delay and decay: do i = i1 + P + 1 , i2 tape % left ( 0 , i ) = ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) / 2.0_wp tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong subroutine add_karplus_strong_stretched ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp integer :: i1 , i2 real ( wp ) :: r integer :: i integer :: P ! Stretch factor S > 1: real ( wp ), parameter :: S = 4._wp i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 P = nint ( RATE / f ) - 2 ! Initial noise: do i = i1 , i1 + P ! 0 <= r < 1 call random_number ( r ) ! Track 0 is used as an auxiliary track: tape % left ( 0 , i ) = Amp * ( 2.0_wp * r - 1.0_wp ) tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Delay and decay: do i = i1 + P + 1 , i2 call random_number ( r ) if ( r < 1 / S ) then tape % left ( 0 , i ) = + 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) else tape % left ( 0 , i ) = + tape % left ( 0 , i - P ) end if tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong_stretched !> Karplus and Strong (1983) algorithm for obtaining a percussion sound. !> Typically, P is taken to be between 150 and 1000. !> Caution: this algorithm overwrites what may have existed on the !> track at the chosen location. !> You may also want to modify the b parameter to make some weird sounds, !> somewhere between percussion and guitar... !> http://crypto.stanford.edu/~blynn/sound/karplusstrong.html !> https://en.wikipedia.org/wiki/Karplus%E2%80%93Strong_string_synthesis subroutine add_karplus_strong_drum ( tape , track , t1 , t2 , P , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , P real ( wp ), intent ( in ) :: t1 , t2 , Amp integer :: i1 , i2 real ( wp ) :: r integer :: i ! 0 <= b <= 1 but b = 0.5 is the best value for good drums: real ( wp ), parameter :: b = 0.5_wp real ( wp ) :: the_sign i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 ! Track 0 is used as an auxiliary track. ! Attack: tape % left ( 0 , i1 : i1 + P ) = Amp tape % right ( 0 , i1 : i1 + P ) = Amp ! Evolution and decay: do i = i1 + P + 1 , i2 ! The sign of the sample is random: call random_number ( r ) if ( r < b ) then the_sign = + 1._wp else the_sign = - 1._wp end if ! Mean of samples i-P and i-P-1: tape % left ( 0 , i ) = the_sign * 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong_drum subroutine add_karplus_strong_drum_stretched ( tape , track , t1 , t2 , P , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track , P real ( wp ), intent ( in ) :: t1 , t2 , Amp integer :: i1 , i2 real ( wp ) :: r integer :: i ! 0 <= b <= 1 but b = 0.5 is the best value for good drums: real ( wp ), parameter :: b = 0.5_wp ! Stretch factor S > 1: real ( wp ), parameter :: S = 4._wp i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 ! Track 0 is used as an auxiliary track. ! Attack: tape % left ( 0 , i1 : i1 + P ) = Amp tape % right ( 0 , i1 : i1 + P ) = Amp ! Evolution and decay: do i = i1 + P + 1 , i2 ! The sign of the sample is random: call random_number ( r ) if ( r < b ) then call random_number ( r ) if ( r < 1 / S ) then tape % left ( 0 , i ) = + 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) else tape % left ( 0 , i ) = + tape % left ( 0 , i - P ) end if else call random_number ( r ) if ( r < 1 / S ) then tape % left ( 0 , i ) = - 0.5_wp * ( tape % left ( 0 , i - P ) + tape % left ( 0 , i - P - 1 )) else tape % left ( 0 , i ) = - tape % left ( 0 , i - P ) end if end if tape % right ( 0 , i ) = tape % left ( 0 , i ) end do ! Transfer (add) on the good track: tape % left ( track , i1 : i2 ) = tape % left ( track , i1 : i2 ) + tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( track , i1 : i2 ) + tape % right ( 0 , i1 : i2 ) end subroutine add_karplus_strong_drum_stretched !> Add white noise on the track: subroutine add_noise ( tape , track , t1 , t2 , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: r ( 1 : 2 ) integer :: i ! Time in seconds: real ( wp ) :: t ! Default value: env = 1._wp t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 ! Noise is different in both channels: call random_number ( r ) if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) tape % left ( track , i ) = tape % left ( track , i ) + Amp * env * ( 2.0_wp * r ( 1 ) - 1.0_wp ) tape % right ( track , i ) = tape % right ( track , i ) + Amp * env * ( 2.0_wp * r ( 2 ) - 1.0_wp ) t = t + dt end do end subroutine !> https://en.wikipedia.org/wiki/Weierstrass_function pure real ( wp ) function weierstrass ( a , b , x ) real ( wp ), intent ( in ) :: a , b , x real ( wp ) :: w , ww integer :: n n = 0 w = 0._wp do ww = w w = w + a ** n * cos ( b ** n * PI * x ) if ( abs ( ww - w ) < 1e-16_wp ) exit n = n + 1 end do weierstrass = w end function !> Add a fractal signal on the track with an envelope: subroutine add_weierstrass ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( in ) :: envelope ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t ! Phase at t=0 s, radians: real ( wp ), parameter :: phi = 0.0_wp ! ADSR Envelope value: real ( wp ) :: env real ( wp ) :: signal real ( wp ) :: a , b integer :: i ! 0 < a < 1. a = 0.975_wp ! If a.b > 1 the function is fractal: b = 1._wp / . 975_wp + 0.005_wp ; env = 1._wp ! Default value if no envelope is passed omega = 2.0_wp * PI * f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt if ( present ( envelope )) env = envelope % get_level ( t1 + t , t1 , t2 ) signal = Amp * weierstrass ( a , b , omega * t + phi ) * env ! It is addd to the already present signal: tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_weierstrass !> Adds a Risset bell sound on the track at t1. !> Jean-Claude Risset, An Introductory Catalogue Of Computer Synthesized Sounds, !> Bell Telephone Laboratories  Murray Hill, New Jersey, 1969. subroutine add_bell ( tape , track , t1 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , f , Amp real ( wp ) :: t , t2 real ( wp ) :: ratio , q real ( wp ) :: signal integer :: i ratio = f / 36 8._wp ! [Risset, 1969] gives a bell with a 368 Hz fundamental. t2 = t1 + 2 0._wp ! The longest partial (hum) is lasting 20 seconds. ! The MIN() is used to stay inside the tape arrays. do concurrent ( i = nint ( t1 * RATE ) : MIN ( nint ( t2 * RATE ) - 1 , tape % samples )) t = t1 + ( i - nint ( t1 * RATE )) * dt q = ( 2 * PI * ratio ) * ( t - t1 ) ! The eleven frequencies come from [Risset, 1969], sound #430. ! x1 and x2 are the start and end of an exponentially decaying envelope ! and y1 and y2 are its height at x1 and x2. signal = Amp * ( & ! Hum (with beating between 224 Hz and 225 Hz): & fit_exp ( t , x1 = t1 + 0._wp , y1 = 1.5_wp , x2 = t1 + 2 0._wp , y2 = 0.001_wp ) * sin ( q * 22 4.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 1._wp , x2 = t1 + 1 8._wp , y2 = 0.001_wp ) * sin ( q * 22 5.0_wp ) & ! Fundamental (with beating between 368 Hz and 369.7 Hz): & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 1.5_wp , x2 = t1 + 1 3._wp , y2 = 0.001_wp ) * sin ( q * 36 8.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2.7_wp , x2 = t1 + 1 1._wp , y2 = 0.001_wp ) * sin ( q * 36 9.7_wp ) & ! Other partials: & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 4._wp , x2 = t1 + 6.5_wp , y2 = 0.001_wp ) * sin ( q * 47 6.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2.5_wp , x2 = t1 + 7._wp , y2 = 0.001_wp ) * sin ( q * 68 0.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2.2_wp , x2 = t1 + 5._wp , y2 = 0.001_wp ) * sin ( q * 80 0.0_wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2._wp , x2 = t1 + 4._wp , y2 = 0.001_wp ) * sin ( q * 109 6._wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2._wp , x2 = t1 + 3._wp , y2 = 0.001_wp ) * sin ( q * 120 0._wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 1.5_wp , x2 = t1 + 2._wp , y2 = 0.001_wp ) * sin ( q * 150 4._wp ) & & + fit_exp ( t , x1 = t1 + 0._wp , y1 = 2._wp , x2 = t1 + 1.5_wp , y2 = 0.001_wp ) * sin ( q * 162 8._wp ) ) tape % left ( track , i ) = tape % left ( track , i ) + signal tape % right ( track , i ) = tape % right ( track , i ) + signal end do end subroutine add_bell end module signals","tags":"","loc":"sourcefile/signals.f90.html"},{"title":"music.f90 – ForSynth","text":"This file depends on sourcefile~~music.f90~~EfferentGraph sourcefile~music.f90 music.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~music.f90~~AfferentGraph sourcefile~music.f90 music.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-05-30 !--------------------------------------------------------------------------- !> Contains music theory elements: scales, circle of fifths, chords, etc. !--------------------------------------------------------------------------- module music use forsynth , only : wp use signals , only : add_sine_wave , add_karplus_strong ! Music theory elements common to the ForMIDI and ForSynth projects: use music_common use tape_recorder_class use envelopes , only : ADSR_envelope implicit none public !> Equal temperament: https://en.wikipedia.org/wiki/Equal_temperament real ( wp ), parameter :: SEMITONE = 2.0_wp ** ( 1.0_wp / 1 2.0_wp ) !> Concert pitch (A note): real ( wp ), parameter :: PITCH = 44 0.0_wp public :: SEMITONE , PITCH , add_note , add_chord , fr contains !> A note of fundamental frequency f with harmonics, based on sine waves. !> https://en.wikipedia.org/wiki/Harmonic subroutine add_note ( tape , track , t1 , t2 , f , Amp , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp type ( ADSR_envelope ), optional , intent ( inout ) :: envelope integer :: h ! Adding harmonics 1f to 40f, with a decreasing amplitude: do h = 1 , 40 call add_sine_wave ( tape , track , t1 , t2 , h * f , Amp / h ** 2 , envelope ) end do end subroutine !> Writes a chord using an array containing the intervals !> (see the music_common module) subroutine add_chord ( tape , track , t1 , t2 , f , Amp , chord , envelope ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp integer , dimension (:), intent ( in ) :: chord type ( ADSR_envelope ), optional , intent ( inout ) :: envelope integer :: i , interval do i = 1 , size ( chord ) interval = chord ( i ) call add_note ( tape , track , t1 , t2 , f * SEMITONE ** interval , Amp , envelope ) end do end subroutine add_chord !> Writes a broken chord using an array containing the intervals !> (see the music_common module). It uses plucked strings (Karplus-Strong). !> For the moment, each note has the same duration. !> https://en.wikipedia.org/wiki/Arpeggio subroutine add_broken_chord ( tape , track , t1 , t2 , f , Amp , chord ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp integer , dimension (:), intent ( in ) :: chord integer :: i , interval real ( wp ) :: dnote ! duration of each note of the chord real ( wp ) :: fnote real ( wp ) :: t dnote = ( t2 - t1 ) / size ( chord ) t = t1 do i = 1 , size ( chord ) interval = chord ( i ) fnote = f * SEMITONE ** interval call add_karplus_strong ( tape , track , t1 = t , t2 = t + dnote , f = fnote , Amp = Amp ) t = t + dnote end do end subroutine add_broken_chord !> Returns the frequency of the note. !> The note name is composed of two or three characters, !> for example \"A4\", \"A#4\", \"Ab4\", where the final character is !> the octave. real ( wp ) function fr ( note ) character ( * ), intent ( in ) :: note ! 0 <= octave <=9 integer :: octave ! Gap relative to PITCH, in semitones: integer :: gap ! ASCII code of the 0 character: integer , parameter :: zero = iachar ( '0' ) select case ( note ( 1 : 1 )) case ( 'C' ) gap = - 9 case ( 'D' ) gap = - 7 case ( 'E' ) gap = - 5 case ( 'F' ) gap = - 4 case ( 'G' ) gap = - 2 case ( 'A' ) gap = 0 case ( 'B' ) gap = + 2 case default print * , \"ERROR! Note name unknown...\" stop end select ! Treating accidentals (sharp, flat) and computing the octave: select case ( note ( 2 : 2 )) case ( 'b' ) gap = gap - 1 octave = iachar ( note ( 3 : 3 )) - zero case ( '#' ) gap = gap + 1 octave = iachar ( note ( 3 : 3 )) - zero case default octave = iachar ( note ( 2 : 2 )) - zero end select if (( octave >= 0 ) . and . ( octave <= 9 )) then gap = gap + ( octave - 4 ) * 12 else print * , \"ERROR! Octave out of bounds [0; 9]\" stop end if ! Computing the frequency of the note: fr = PITCH * SEMITONE ** ( real ( gap , wp )) end function fr end module music","tags":"","loc":"sourcefile/music.f90.html"},{"title":"drum_machine.f90 – ForSynth","text":"This file depends on sourcefile~~drum_machine.f90~~EfferentGraph sourcefile~drum_machine.f90 drum_machine.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~drum_machine.f90->sourcefile~forsynth.f90 sourcefile~signals.f90 signals.f90 sourcefile~drum_machine.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~drum_machine.f90->sourcefile~wav_file_class.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-04-25 ! Last modifications: 2024-06-02 !> A rhythm following a pattern stored in an array. program drum_machine use forsynth , only : wp use wav_file_class , only : WAV_file use signals , only : add_karplus_strong_drum , add_karplus_strong_drum_stretched implicit none type ( WAV_file ) :: demo integer :: i , j real ( wp ) :: t real ( wp ) :: step = 0.25_wp ! Each line is a different drum: integer , dimension ( 3 , 16 ) :: pattern = reshape ( [ & 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , 1 , & 0 , 1 , 0 , 0 , 0 , 1 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 1 , 0 , 0 , & 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 ], & shape ( pattern ), order = [ 2 , 1 ] ) print * , \"**** Demo Drum Machine****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'drum_machine.wav' , tracks = 3 , duration = 3 3._wp ) associate ( tape => demo % tape_recorder ) ! A rhythm following the above pattern: t = 0._wp do i = 1 , 8 do j = 1 , 16 ! We use one track for each kind of drum: if ( pattern ( 1 , j ) == 1 ) then call add_karplus_strong_drum ( tape , track = 1 , t1 = t , t2 = t + 2 * step , P = 150 , Amp = 1._wp ) end if if ( pattern ( 2 , j ) == 1 ) then call add_karplus_strong_drum ( tape , track = 2 , t1 = t , t2 = t + 2 * step , P = 400 , Amp = 1._wp ) end if if ( pattern ( 3 , j ) == 1 ) then call add_karplus_strong_drum_stretched ( tape , track = 3 , t1 = t , t2 = t + 2 * step , P = 150 , Amp = 0.5_wp ) end if t = t + step end do end do end associate print * , \"Final mix...\" ! The three drums are positionned on the left, the center and the right: call demo % mix_tracks ( pan = [ - 0.5_wp , 0._wp , + 0.5_wp ]) call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program drum_machine","tags":"","loc":"sourcefile/drum_machine.f90.html"},{"title":"demo_effects.f90 – ForSynth","text":"This file depends on sourcefile~~demo_effects.f90~~EfferentGraph sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~demo_effects.f90->sourcefile~audio_effects.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~demo_effects.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~demo_effects.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~demo_effects.f90->sourcefile~music_common.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~demo_effects.f90->sourcefile~wav_file_class.f90 sourcefile~audio_effects.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-02 !> All available audio effects are applied sequentially on a chord sequence. program demo_effects use forsynth , only : wp use wav_file_class , only : WAV_file use music_common , only : MAJOR_CHORD use music , only : fr , add_chord use audio_effects , only : apply_fuzz_effect , apply_tremolo_effect , & & apply_autopan_effect , apply_delay_effect use envelopes , only : ADSR_envelope implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env integer :: i real ( wp ) :: t , dnote print * , \"**** Demo of the audio effects ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'demo_effects.wav' , tracks = 1 , duration = 12 0._wp ) ! We create an ADSR envelope that will be passed to signals (add_chord): call env % new ( A = 1 0._wp , D = 4 0._wp , S = 8 0._wp , R = 3 0._wp ) ! Notes duration in seconds: dnote = 1.5_wp associate ( tape => demo % tape_recorder ) print * , \"Track 1: repeating G D F C chords...\" t = 0.0_wp call add_chord ( tape , track = 1 , t1 = t , t2 = t + dnote , f = fr ( \"G3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + dnote , t2 = t + 2 * dnote , f = fr ( \"D3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 2 * dnote , t2 = t + 3 * dnote , f = fr ( \"F3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 3 * dnote , t2 = t + 4 * dnote , f = fr ( \"C3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) ! Repeat those four chords until the end of the track: do i = 1 , 19 call demo % copy_section ( from_track = 1 , to_track = 1 , t1 = t , t2 = t + 4 * dnote , t3 = 4 * dnote * i ) end do ! Apply the different effects, every four chords, ! after four chords without effect: call apply_fuzz_effect ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 8 * dnote , level = 0.8_wp ) call apply_tremolo_effect ( tape , track = 1 , t1 = t + 8 * dnote , t2 = t + 12 * dnote , f = 4.0_wp , AmpLFO = 0.3_wp ) call apply_autopan_effect ( tape , track = 1 , t1 = t + 12 * dnote , t2 = t + 16 * dnote , f = 0.33_wp , AmpLFO = 0.8_wp ) call apply_delay_effect ( tape , track = 1 , t1 = t + 16 * dnote , t2 = t + 20 * dnote , delay = 0.4_wp , Amp = 0.4_wp ) end associate print * , \"Final mix...\" ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program demo_effects","tags":"","loc":"sourcefile/demo_effects.f90.html"},{"title":"audio_effects.f90 – ForSynth","text":"This file depends on sourcefile~~audio_effects.f90~~EfferentGraph sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~audio_effects.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~audio_effects.f90~~AfferentGraph sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~audio_effects.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~audio_effects.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~audio_effects.f90 sourcefile~shepard_scale.f90 shepard_scale.f90 sourcefile~shepard_scale.f90->sourcefile~audio_effects.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2023-05-26 !> Various audio effects module audio_effects use forsynth , only : wp , RATE , PI , dt use tape_recorder_class implicit none private public :: apply_delay_effect , apply_fuzz_effect , apply_tremolo_effect , & & apply_autopan_effect , apply_reverse_effect contains !> Add the sound from \"delay\" seconds before, !> and multiply by Amp<1 for dampening. subroutine apply_delay_effect ( tape , track , t1 , t2 , delay , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , delay , Amp integer :: i , j integer :: id ! Delay as an integer: id = nint ( delay / dt ) ! Can not be parallelized: do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 j = i - id if ( j > 0 ) then tape % left ( track , i ) = tape % left ( track , i ) + Amp * tape % left ( track , j ) tape % right ( track , i ) = tape % right ( track , i ) + Amp * tape % right ( track , j ) end if end do end subroutine !> Apply distorsion with hard clipping !> https://en.wikipedia.org/wiki/Distortion_(music) subroutine apply_fuzz_effect ( tape , track , t1 , t2 , level ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , level integer :: i do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) if ( abs ( tape % left ( track , i )) > level ) then tape % left ( track , i ) = sign ( level , tape % left ( track , i )) end if if ( abs ( tape % right ( track , i )) > level ) then tape % right ( track , i ) = sign ( level , tape % right ( track , i )) end if end do end subroutine !> A sinusoidal modulation of the amplitude of a signal (tremolo) : !> f : tremolo frequency (typically a few Hz) !> AmpLFO : tremolo amplitude in [0 ; 1] !> https://en.wikipedia.org/wiki/Vibrato#Vibrato_and_tremolo/ subroutine apply_tremolo_effect ( tape , track , t1 , t2 , f , AmpLFO ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , AmpLFO integer :: i real ( wp ) :: omegaLFO real ( wp ) :: t omegaLFO = 2 * PI * f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt tape % left ( track , i ) = tape % left ( track , i ) * ( 1.0_wp - AmpLFO * sin ( omegaLFO * t )) tape % right ( track , i ) = tape % right ( track , i ) * ( 1.0_wp - AmpLFO * sin ( omegaLFO * t )) end do end subroutine !> Make the sound move from one channel to the other one at a frequency f !> and with an amplitude AmpLFO in [0 ; 1]. subroutine apply_autopan_effect ( tape , track , t1 , t2 , f , AmpLFO ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , AmpLFO real ( wp ), parameter :: phi = 0.0_wp integer :: i real ( wp ) :: omegaLFO real ( wp ) :: t omegaLFO = 2 * PI * f do concurrent ( i = nint ( t1 * RATE ) : nint ( t2 * RATE ) - 1 ) t = ( i - nint ( t1 * RATE )) * dt tape % left ( track , i ) = tape % left ( track , i ) * ( 1.0_wp - AmpLFO * sin ( omegaLFO * t + phi )) tape % right ( track , i ) = tape % right ( track , i ) * ( 1.0_wp - AmpLFO * cos ( omegaLFO * t + phi )) end do end subroutine !> Copy the samples at the same t1 but in reverse order: subroutine apply_reverse_effect ( tape , track , t1 , t2 ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 integer :: i , i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 ! Track 0 is used as an auxiliary track: do concurrent ( i = i1 : i2 ) tape % left ( 0 , i ) = tape % left ( track , i1 - i + i2 ) tape % right ( 0 , i ) = tape % right ( track , i1 - i + i2 ) end do ! Transfer on the good track: tape % left ( track , i1 : i2 ) = tape % left ( 0 , i1 : i2 ) tape % right ( track , i1 : i2 ) = tape % right ( 0 , i1 : i2 ) end subroutine end module audio_effects","tags":"","loc":"sourcefile/audio_effects.f90.html"},{"title":"wav_file_class.f90 – ForSynth","text":"This file depends on sourcefile~~wav_file_class.f90~~EfferentGraph sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~wav_file_class.f90~~AfferentGraph sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~wav_file_class.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~wav_file_class.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~wav_file_class.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~wav_file_class.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~wav_file_class.f90 sourcefile~doppler_effect.f90 doppler_effect.f90 sourcefile~doppler_effect.f90->sourcefile~wav_file_class.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~wav_file_class.f90 sourcefile~drum_machine.f90 drum_machine.f90 sourcefile~drum_machine.f90->sourcefile~wav_file_class.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~wav_file_class.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~wav_file_class.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~wav_file_class.f90 sourcefile~shepard_risset_glissando.f90 shepard_risset_glissando.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~wav_file_class.f90 sourcefile~shepard_scale.f90 shepard_scale.f90 sourcefile~shepard_scale.f90->sourcefile~wav_file_class.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-07-14 !> The main class that you will use to create your WAV files. module wav_file_class use , intrinsic :: iso_fortran_env , only : INT16 , INT32 , INT64 use forsynth , only : wp , RATE use tape_recorder_class implicit none !> Maximum amplitude in a WAV [-32768 ; +32767]: integer , parameter :: MAX_AMPLITUDE = 32767 integer :: status type , extends ( tape_recorder ) :: WAV_file character ( len = :), allocatable :: filename integer :: fileunit contains procedure :: create_WAV_file procedure :: close_WAV_file procedure :: get_name procedure , private :: write_header procedure , private :: write_normalized_data end type WAV_file private :: status public :: WAV_file contains !> Create a WAV file with a header: subroutine create_WAV_file ( self , filename , tracks , duration ) class ( WAV_file ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer , intent ( in ) :: tracks real ( wp ), intent ( in ) :: duration call self % new ( tracks , duration ) self % filename = filename open ( newunit = self % fileunit , file = self % filename , access = 'stream' , status = 'replace' , action = 'write' ) call self % write_header () end subroutine create_WAV_file !> Returns the name of the WAV file: function get_name ( self ) class ( WAV_file ), intent ( inout ) :: self character ( len ( self % filename )) :: get_name get_name = self % filename end function !> Creates the 44 bytes WAV header and prints some information: subroutine write_header ( self ) class ( WAV_file ), intent ( inout ) :: self !**************** ! WAV parameters: !**************** ! Number of channels: 1 for mono, 2 for stereo, etc. integer ( INT16 ), parameter :: CHANNELS = 2 integer ( INT16 ), parameter :: BITS_PER_SAMPLE = 16 integer ( INT64 ) :: DATA_BYTES integer ( INT32 ) :: file_size , bytes_per_second , data_size integer ( INT16 ) :: bytes_per_sample print * , \"Nb of tracks, excluding track 0:\" , self % tracks DATA_BYTES = ( BITS_PER_SAMPLE / 8 ) * CHANNELS * self % samples print * , \"Used RAM:   \" , DATA_BYTES * self % tracks , \"bytes\" print * , \"File size ~ \" , DATA_BYTES , \"bytes\" associate ( u => self % fileunit ) ! RIFF format: write ( u , iostat = status ) \"RIFF\" ! Remaining bytes after this data: file_size = 36 + DATA_BYTES write ( u , iostat = status ) file_size write ( u , iostat = status ) \"WAVE\" ! ***** First sub-chunk ***** ! Don't remove the final space in the string! write ( u , iostat = status ) \"fmt \" ! Remaining bytes in this sub-chunk, 16 for PCM (32 bits integer): write ( u , iostat = status ) 16_INT32 ! Encoding is 1 for PCM (16 bits integer): write ( u , iostat = status ) 1_INT16 write ( u , iostat = status ) int ( CHANNELS , kind = INT16 ) ! Sampling frequency: write ( u , iostat = status ) int ( RATE , kind = INT32 ) bytes_per_second = RATE * CHANNELS * ( BITS_PER_SAMPLE / 8 ) write ( u , iostat = status ) bytes_per_second bytes_per_sample = CHANNELS * ( BITS_PER_SAMPLE / 8 ) write ( u , iostat = status ) bytes_per_sample write ( u , iostat = status ) BITS_PER_SAMPLE ! ***** Second sub-chunk ***** write ( u , iostat = status ) \"data\" data_size = self % samples * CHANNELS * ( BITS_PER_SAMPLE / 8 ) write ( u , iostat = status ) data_size end associate end subroutine write_header !> This method normalizes the sound amplitude on track 0, before saving !> the left and right channels in the WAV file. subroutine write_normalized_data ( self ) class ( WAV_file ), intent ( inout ) :: self integer :: i real ( wp ) :: maxi ! Looking for the maximum amplitude (must not be zero): maxi = max ( 1e-16_wp , maxval ( abs ( self % left ( 0 , :))), maxval ( abs ( self % right ( 0 , :)))) do i = 0 , self % samples ! Writing the amplitude of left then right channels as 16 bit signed integers: write ( self % fileunit , iostat = status ) nint (( self % left ( 0 , i ) / maxi * MAX_AMPLITUDE ), kind = INT16 ) write ( self % fileunit , iostat = status ) nint (( self % right ( 0 , i ) / maxi * MAX_AMPLITUDE ), kind = INT16 ) end do end subroutine !> Must be called at the end. It normalizes the channels, writes them in the !> WAV file and closes it. It also deallocate the tape arrays. subroutine close_WAV_file ( self ) class ( WAV_file ), intent ( inout ) :: self call self % write_normalized_data () close ( self % fileunit , iostat = status ) call self % tape_recorder % finalize () end subroutine end module wav_file_class","tags":"","loc":"sourcefile/wav_file_class.f90.html"},{"title":"doppler_effect.f90 – ForSynth","text":"This file depends on sourcefile~~doppler_effect.f90~~EfferentGraph sourcefile~doppler_effect.f90 doppler_effect.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~doppler_effect.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~doppler_effect.f90->sourcefile~wav_file_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-28 ! Last modifications: 2024-05-31 !> A simulation of Doppler effect, with a car passing in front of you. !> https://fr.wikipedia.org/wiki/Effet_Doppler program doppler_effect use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file implicit none type ( WAV_file ) :: demo real ( wp ) :: panL , panR ! Pulsation (radians/second): real ( wp ) :: omega real ( wp ) :: t , tobs real ( wp ) :: Amp integer :: i , j real ( wp ) :: x0 , x , y real ( wp ), parameter :: duration = 7._wp ! Duration in seconds real ( wp ), parameter :: y0 = 10 ! m real ( wp ), parameter :: v = 13000 0._wp / 3600 ! 130 km/h (car velocity) ! https://en.wikipedia.org/wiki/Speed_of_sound real ( wp ), parameter :: c = 343 ! m/s at 20°C in air real ( wp ), parameter :: f = 50 ! Hz print * , \"**** Creating doppler_effect.wav ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'doppler_effect.wav' , tracks = 1 , duration = duration ) associate ( tape => demo % tape_recorder ) !> The Observer is static at the origin, !> the car is Moving along x at a constant velocity v !>                        &#94; y !>                        | !>      ****M*************y0**************> !>                        | !> ----x0-----------------O-------------------> x !>                        | omega = 2 * PI * f x0 = - v * duration / 2 ! y is constant: y = y0 print '(3A8, A10, 2A8)' , \"tobs\" , \"t\" , \"x\" , \"Amp\" , \"panL\" , \"panR\" tobs = 0 do i = 0 , nint ( duration * RATE ) - 1 !> The frequency perceived by the observer (Doppler effect) !> is fobs = f / (1 - vr/c) but we don't need to compute it. !> The signal heard by the observer at tobs was emitted earlier by the !> car at t, from a distance r(t): !> tobs = t + r(t) / c !> By developing r(t) we can finally obtain a quadratic equation: !> (c**2-v**2) * t**2 - (2*tobs*c**2 + 2*x0*v) *t + (tobs**2 * c**2 - x0**2 - y**2) = 0 !> The time t is the unique physical solution of that equation: t = the_solution ( a = c ** 2 - v ** 2 , b =- ( 2 * tobs * c ** 2 + 2 * x0 * v ), c = ( tobs ** 2 * c ** 2 - x0 ** 2 - y ** 2 ), tobs = tobs ) ! The position of the car at t was: x = x0 + v * t !> The amplitude of the observed signal is decreasing in r**2: Amp = 1 / ( x ** 2 + y ** 2 ) ! We simulate a stereo effect by using this arbitrary law: ! (note that x0<0 and at tobs=0 x<x0) panR = abs (( max ( x , x0 ) - x0 ) / ( 2 * x0 )) panL = 1 - panR tape % left ( 1 , i ) = panL * Amp * sin ( omega * t ) tape % right ( 1 , i ) = panR * Amp * sin ( omega * t ) ! A signal with only even harmonics, to sound like a motor: do j = 2 , 40 , + 2 tape % left ( 1 , i ) = tape % left ( 1 , i ) + panL * Amp / j ** 1.3_wp * sin ( j * omega * t ) tape % right ( 1 , i ) = tape % right ( 1 , i ) + panR * Amp / j ** 1.3_wp * sin ( j * omega * t ) end do if ( mod ( i , RATE / 4 ) == 0 ) print '(3F8.2, ES10.2, 2F8.3)' , tobs , t , x , Amp , panL , panR tobs = tobs + dt end do end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () contains !> We solve the Quadratic equation, !> but physically one and only one solution can exist: !> we know the sound was emitted before we hear it!> real ( wp ) function the_solution ( a , b , c , tobs ) real ( wp ), intent ( in ) :: a , b , c , tobs real ( wp ) :: delta , t1 , t2 delta = b ** 2 - 4 * a * c if ( delta >= 0 ) then t1 = ( - b + sqrt ( delta )) / ( 2 * a ) t2 = ( - b - sqrt ( delta )) / ( 2 * a ) if ( t1 <= tobs ) then if ( t2 <= tobs ) then error stop \"ERROR: two solutions, physically impossible\" else the_solution = t1 end if else if ( t2 <= tobs ) then the_solution = t2 else error stop \"ERROR: no solution (1)\" end if else error stop \"ERROR: no solution, delta<0 (2)\" end if end function end program doppler_effect","tags":"","loc":"sourcefile/doppler_effect.f90.html"},{"title":"morse_code.f90 – ForSynth","text":"This file depends on sourcefile~~morse_code.f90~~EfferentGraph sourcefile~morse_code.f90 morse_code.f90 sourcefile~signals.f90 signals.f90 sourcefile~morse_code.f90->sourcefile~signals.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~morse_code.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~morse_code.f90~~AfferentGraph sourcefile~morse_code.f90 morse_code.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~morse_code.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2025-02-01 ! Last modification: 2025-02-03 !> Basic Morse code support. !> https://en.wikipedia.org/wiki/Morse_code module morse_code use tape_recorder_class use signals , only : add_sine_wave implicit none private public :: string_to_morse , add_morse_code ! Alphabet (26) and numbers (10): character ( len = 5 ), parameter :: morse_table ( 36 ) = [ & '.-   ' , '-... ' , '-.-. ' , '-..  ' , '.    ' , '..-. ' , '--.  ' , '.... ' , '..   ' , '.--- ' , & '-.-  ' , '.-.. ' , '--   ' , '-.   ' , '---  ' , '.--. ' , '--.- ' , '.-.  ' , '...  ' , '-    ' , & '..-  ' , '...- ' , '.--  ' , '-..- ' , '-.-- ' , '--.. ' , & '-----' , '.----' , '..---' , '...--' , '....-' , '.....' , '-....' , '--...' , '---..' , '----.' ] contains !> This function receives a string and returns its Morse code translation. !> The input string can contain only alphabetic characters in upper or lower case, !> digits 0..9 and spaces. All other characters will be considered as spaces. !> Characters inside words are separated by one space, and words by two spaces. function string_to_morse ( string ) result ( morse ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: morse character ( len = 1 ) :: c integer :: i , k morse = \"\" do i = 1 , len_trim ( string ) c = string ( i : i ) select case ( c ) case ( 'A' : 'Z' ) k = iachar ( c ) - iachar ( 'A' ) + 1 case ( 'a' : 'z' ) k = iachar ( c ) - iachar ( 'a' ) + 1 case ( '0' : '9' ) k = iachar ( c ) - iachar ( '0' ) + 27 case default k = 0 ! A space end select if ( k /= 0 ) then morse = morse // trim ( morse_table ( k )) // ' ' else morse = morse // ' ' end if end do morse = trim ( morse ) end function string_to_morse !> Adds on the specified track a Morse code translation of the string, starting at !> time t1. The frequency f must correspond to a high tone, for example 880 Hz. subroutine add_morse_code ( tape , track , t1 , f , Amp , string ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , f , Amp character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: c real ( wp ) :: t ! Time in seconds real ( wp ) :: dot = 0.050_wp ! The fundamental duration in seconds integer :: i t = t1 do i = 1 , len_trim ( string ) c = string ( i : i ) select case ( c ) case ( '.' ) call add_sine_wave ( tape , track , t , t + 1 * dot , f , Amp ) t = t + 1 * dot case ( '-' ) ! A dash last three times longer than a dot call add_sine_wave ( tape , track , t , t + 3 * dot , f , Amp ) t = t + 3 * dot case ( ' ' ) t = t + ( 3 - 1 ) * dot ! Silence between letters of a word, ! taking into account the silence added after END SELECT ! A double space means we are between two words, and the ! total silence must last 7 dots: if ( string ( i + 1 : i + 1 ) == ' ' ) then t = t + 4 * dot end if end select t = t + dot ! A silence between dots and dashes in a character end do end subroutine add_morse_code end module morse_code","tags":"","loc":"sourcefile/morse_code.f90.html"},{"title":"radioactivity.f90 – ForSynth","text":"This file depends on sourcefile~~radioactivity.f90~~EfferentGraph sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~radioactivity.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~radioactivity.f90->sourcefile~forsynth.f90 sourcefile~morse_code.f90 morse_code.f90 sourcefile~radioactivity.f90->sourcefile~morse_code.f90 sourcefile~music.f90 music.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~radioactivity.f90->sourcefile~music_common.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~radioactivity.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~radioactivity.f90->sourcefile~wav_file_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~morse_code.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90 signals.f90 sourcefile~morse_code.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2025-01-29 ! Last modifications: 2025-02-04 !> Radioactive decay of a population of atoms. A tribute to Kraftwerk. !> Chords are played on a 2nd track and Morse code on a third track. program radioactivity use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use tape_recorder_class use music , only : fr , add_chord use music_common , only : WHOLE_TONE_SCALE , MAJOR_CHORD use envelopes , only : ADSR_envelope use morse_code , only : string_to_morse , add_morse_code implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env integer , parameter :: N0 = 5000 ! Number of atoms integer :: N = N0 ! Number of remaining radioactive atoms integer :: atom ( N0 ) = 1 ! The population of atoms, in state 1 real ( wp ) :: t = 0 ! Time in seconds real ( wp ) :: t_end ! Position of the end of the first track real ( wp ) :: d_note ! Duration of each chord real ( wp ), parameter :: duration = 12 0._wp ! Duration of the WAV file real ( wp ), parameter :: tau = 8._wp ! Half-life in seconds real ( wp ), parameter :: delta_t = tau / 10000 ! Time step of the simulation ! Decay probability during delta_t: real ( wp ), parameter :: p = 1 - exp ( - log ( 2._wp ) * delta_t / tau ) real ( wp ) :: r ! Pseudo-random number integer :: i , j , note , nb_notes ! Melody of the chords on track 2: integer , parameter :: notes ( 1 : 40 ) = [ 6 , 5 , 6 , 5 , 6 , 4 , 5 , 4 , 5 , 3 , 4 , 3 , 4 , 2 , 3 , 2 , 3 , 1 , 2 , & & 1 , 2 , 1 , 3 , 2 , 3 , 2 , 4 , 3 , 4 , 3 , 5 , 4 , 5 , 4 , 6 , 5 , 6 , 5 , 6 , 6 ] print * , \"It may take a few minutes to compute...\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'radioactivity.wav' , tracks = 3 , duration = duration ) ! We create an ADSR envelope that will be passed to signals (add_chord): call env % new ( A = 1 5._wp , D = 1 5._wp , S = 7 0._wp , R = 4 5._wp ) do ! Scanning the whole population: do i = 1 , N0 ! Is this atom still in its original state? if ( atom ( i ) /= 0 ) then ! Monte Carlo event: call random_number ( r ) if ( r < p ) then ! Radioactive decay atom ( i ) = 0 N = N - 1 if ( t + 5._wp < duration ) then call add_geiger_ping ( demo % tape_recorder , track = 1 , t1 = t , t2 = t + 5._wp , & & f = 44 0._wp , Amp = 1._wp ) end if end if end if end do t = t + delta_t if ( N == 0 ) exit ! No more radioactive atoms end do ! Track 2: synth chords t_end = t nb_notes = 2 * 40 d_note = t_end / nb_notes do j = 1 , nb_notes ! The same sequence is played twice: if ( j <= 40 ) then note = notes ( j ) else note = notes ( j - 40 ) end if call add_chord ( demo % tape_recorder , track = 2 , t1 = ( j - 1 ) * d_note , t2 = j * d_note , & & f = fr ( trim ( WHOLE_TONE_SCALE ( note )) // \"3\" ), & & Amp = 0.1_wp , chord = MAJOR_CHORD , envelope = env ) end do ! Track 3: Morse code call add_morse_code ( demo % tape_recorder , track = 3 , t1 = 2._wp , f = 88 0._wp , & & Amp = 0.3_wp , string = string_to_morse ( \"RADIOACTIVITY\" )) call add_morse_code ( demo % tape_recorder , track = 3 , t1 = 3 5._wp , f = 88 0._wp , & & Amp = 0.3_wp , string = string_to_morse ( \"DISCOVERED BY MADAME CURIE\" )) call add_morse_code ( demo % tape_recorder , track = 3 , t1 = 7 5._wp , f = 88 0._wp , & & Amp = 0.3_wp , string = string_to_morse ( \"IS IN THE AIR FOR YOU AND ME\" )) ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () contains !> Adds the signal of a radioactive decay heard with a Geiger counter. subroutine add_geiger_ping ( tape , track , t1 , t2 , f , Amp ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 , f , Amp real ( wp ) :: b ! Pulsation (radians/second): real ( wp ) :: omega ! Time in seconds: real ( wp ) :: t integer :: i omega = 2 * PI * f t = 0._wp do i = nint ( t1 * RATE ), nint ( t2 * RATE ) - 1 ! Bessel functions of the first kind: a short ping b = Amp * bessel_jn ( 1 , omega * t ) * bessel_jn ( 2 , omega * t ) tape % left ( track , i ) = tape % left ( track , i ) + b tape % right ( track , i ) = tape % right ( track , i ) + b t = t + dt end do end subroutine add_geiger_ping end program radioactivity","tags":"","loc":"sourcefile/radioactivity.f90.html"},{"title":"all_signals.f90 – ForSynth","text":"This file depends on sourcefile~~all_signals.f90~~EfferentGraph sourcefile~all_signals.f90 all_signals.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~all_signals.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~all_signals.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~signals.f90 signals.f90 sourcefile~all_signals.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~all_signals.f90->sourcefile~wav_file_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-02 !> Plays sequentially each type of available signal. program all_signals use forsynth , only : wp use wav_file_class , only : WAV_file use music , only : fr use signals , only : add_sine_wave , add_square_wave , & & add_sawtooth_wave , add_triangle_wave , & & add_karplus_strong , add_karplus_strong_stretched , & & add_noise , add_weierstrass use envelopes , only : ADSR_envelope implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env real ( wp ) :: t , dnote real ( wp ) :: f_A print * , \"**** Demo of the available signals ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'all_signals.wav' , tracks = 1 , duration = 3 0._wp ) ! We create an ADSR envelope that will be passed to signals: call env % new ( A = 3 0._wp , D = 2 0._wp , S = 8 0._wp , R = 3 0._wp ) ! Notes frequencies are obtained with the fr() function: f_A = fr ( \"A3\" ) ! A 220 Hz ! Notes duration in seconds: dnote = 3.0_wp t = 0.0_wp associate ( tape => demo % tape_recorder ) ! We add each signal on the track between times t1 and t2: print * , \"Sinusoidal signal\" call add_sine_wave ( tape , track = 1 , t1 = t , t2 = t + dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Square wave\" call add_square_wave ( tape , track = 1 , t1 = t + dnote , t2 = t + 2 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Sawtooth wave\" call add_sawtooth_wave ( tape , track = 1 , t1 = t + 2 * dnote , t2 = t + 3 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Triangle wave\" call add_triangle_wave ( tape , track = 1 , t1 = t + 3 * dnote , t2 = t + 4 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Summing the four signals together\" call add_sine_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) call add_square_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) call add_sawtooth_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) call add_triangle_wave ( tape , track = 1 , t1 = t + 4 * dnote , t2 = t + 5 * dnote , f = f_A , Amp = 0.5_wp , envelope = env ) print * , \"Noise\" call add_noise ( tape , track = 1 , t1 = t + 5 * dnote , t2 = t + 6 * dnote , Amp = 1.0_wp , envelope = env ) print * , \"Weierstrass\" call add_weierstrass ( tape , track = 1 , t1 = t + 6 * dnote , t2 = t + 7 * dnote , f = f_A , Amp = 1.0_wp , envelope = env ) print * , \"Karplus Strong\" call add_karplus_strong ( tape , track = 1 , t1 = t + 7 * dnote , t2 = t + 8 * dnote , f = f_A , Amp = 1.0_wp ) print * , \"Karplus Strong stretched\" call add_karplus_strong_stretched ( tape , track = 1 , t1 = t + 8 * dnote , t2 = t + 9 * dnote , f = f_A , Amp = 1.0_wp ) end associate print * , \"Final mix...\" ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program all_signals","tags":"","loc":"sourcefile/all_signals.f90.html"},{"title":"tape_recorder_class.f90 – ForSynth","text":"This file depends on sourcefile~~tape_recorder_class.f90~~EfferentGraph sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tape_recorder_class.f90~~AfferentGraph sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90 music.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~misc_sounds.f90->sourcefile~wav_file_class.f90 sourcefile~morse_code.f90 morse_code.f90 sourcefile~morse_code.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90 signals.f90 sourcefile~morse_code.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~tape_recorder_class.f90 sourcefile~radioactivity.f90->sourcefile~envelopes.f90 sourcefile~radioactivity.f90->sourcefile~morse_code.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 sourcefile~radioactivity.f90->sourcefile~wav_file_class.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~envelopes.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~all_signals.f90->sourcefile~signals.f90 sourcefile~all_signals.f90->sourcefile~wav_file_class.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~envelopes.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~arpeggios.f90->sourcefile~signals.f90 sourcefile~arpeggios.f90->sourcefile~wav_file_class.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~audio_effects.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~blues.f90->sourcefile~signals.f90 sourcefile~blues.f90->sourcefile~wav_file_class.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~audio_effects.f90 sourcefile~chords_and_melody.f90->sourcefile~envelopes.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~chords_and_melody.f90->sourcefile~signals.f90 sourcefile~chords_and_melody.f90->sourcefile~wav_file_class.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~audio_effects.f90 sourcefile~demo_effects.f90->sourcefile~envelopes.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~demo_effects.f90->sourcefile~wav_file_class.f90 sourcefile~doppler_effect.f90 doppler_effect.f90 sourcefile~doppler_effect.f90->sourcefile~wav_file_class.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~envelopes.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~drone_music.f90->sourcefile~wav_file_class.f90 sourcefile~drum_machine.f90 drum_machine.f90 sourcefile~drum_machine.f90->sourcefile~signals.f90 sourcefile~drum_machine.f90->sourcefile~wav_file_class.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 sourcefile~multiplication_bells.f90->sourcefile~signals.f90 sourcefile~multiplication_bells.f90->sourcefile~wav_file_class.f90 sourcefile~shepard_risset_glissando.f90 shepard_risset_glissando.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~envelopes.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~wav_file_class.f90 sourcefile~shepard_scale.f90 shepard_scale.f90 sourcefile~shepard_scale.f90->sourcefile~audio_effects.f90 sourcefile~shepard_scale.f90->sourcefile~wav_file_class.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-05-31 !> This is the basic class, representing a numeric tape recorder with audio tracks. module tape_recorder_class use forsynth , only : wp , RATE implicit none type tape_recorder !> Number of audio tracks (excluding track 0 reserved for the final mix): integer :: tracks !> Duration in seconds: real ( wp ) :: duration !> Number of samples: integer :: samples !> Two arrays stocking the stereo tracks: real ( wp ), dimension (:, :), allocatable :: left , right contains procedure :: new procedure :: clear_tracks procedure :: mix_tracks procedure :: copy_section procedure :: finalize final :: auto_finalize end type tape_recorder public :: tape_recorder contains subroutine new ( self , tracks , duration ) class ( tape_recorder ), intent ( inout ) :: self ! Track 0 excluded: integer , intent ( in ) :: tracks real ( wp ), intent ( in ) :: duration self % duration = duration self % tracks = tracks self % samples = nint ( duration * RATE ) allocate ( self % left ( 0 : tracks , 0 : self % samples )) allocate ( self % right ( 0 : tracks , 0 : self % samples )) call self % clear_tracks () end subroutine !> Erase all tracks on all the channels of the tape. subroutine clear_tracks ( self ) class ( tape_recorder ), intent ( inout ) :: self self % left = 0.0_wp self % right = 0.0_wp end subroutine !> Tracks 1 to tracks-1 are mixed on track 0. subroutine mix_tracks ( self , levels , pan ) class ( tape_recorder ), intent ( inout ) :: self real ( wp ), dimension ( 1 : self % tracks ), intent ( in ), optional :: levels real ( wp ), dimension ( 1 : self % tracks ), intent ( in ), optional :: pan real ( wp ), dimension ( 1 : self % tracks ) :: pano real ( wp ) :: panL , panR integer :: track ! As the track 0 can be used as an auxiliary track by some routines, ! it is important to clear it before the final mixing: self % left ( 0 , :) = 0.0_wp self % right ( 0 , :) = 0.0_wp ! Pan is centered on 0 and -1 < pan < +1 ! Default is 0: if (. not . present ( pan )) then pano = 0._wp else ! Each element of pan(:) must be in [-1 ; +1] pano = max ( - 1._wp , min ( + 1._wp , pan )) end if do track = 1 , self % tracks ! Panoramic factors: if ( pano ( track ) > 0._wp ) then panL = 1._wp - pano ( track ) panR = 1._wp else if ( pano ( track ) < 0._wp ) then panL = 1._wp panR = 1._wp + pano ( track ) else panL = 1._wp panR = 1._wp end if if (. not . present ( levels )) then self % left ( 0 , :) = self % left ( 0 , :) + panL * self % left ( track , :) self % right ( 0 , :) = self % right ( 0 , :) + panR * self % right ( track , :) else self % left ( 0 , :) = self % left ( 0 , :) + panL * levels ( track ) * self % left ( track , :) self % right ( 0 , :) = self % right ( 0 , :) + panR * levels ( track ) * self % right ( track , :) end if end do end subroutine !> Copy section t1...t2 at t3, either on the same track or another one. !> The content already present at t3 is overwritten. !> The code suppose that t1 < t2 < t3. subroutine copy_section ( self , from_track , to_track , t1 , t2 , t3 ) class ( tape_recorder ), intent ( inout ) :: self integer , intent ( in ) :: from_track , to_track real ( wp ), intent ( in ) :: t1 , t2 , t3 integer :: i , i1 , i3 i1 = nint ( t1 * RATE ) do i = i1 , nint ( t2 * RATE ) - 1 ! The position of the sample receiving the copy: i3 = nint ( t3 * RATE ) + ( i - i1 ) ! To avoid pasting beyond the end of the track: if ( i3 <= self % samples ) then self % left ( to_track , i3 ) = self % left ( from_track , i ) self % right ( to_track , i3 ) = self % right ( from_track , i ) else exit end if end do end subroutine !> Called by the close_WAV_file() method. subroutine finalize ( self ) class ( tape_recorder ), intent ( inout ) :: self deallocate ( self % left ) deallocate ( self % right ) end subroutine !> An automatic finalizer, by security. subroutine auto_finalize ( self ) type ( tape_recorder ), intent ( inout ) :: self deallocate ( self % left ) deallocate ( self % right ) end subroutine end module tape_recorder_class","tags":"","loc":"sourcefile/tape_recorder_class.f90.html"},{"title":"arpeggios.f90 – ForSynth","text":"This file depends on sourcefile~~arpeggios.f90~~EfferentGraph sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~arpeggios.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~arpeggios.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~arpeggios.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~arpeggios.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~arpeggios.f90->sourcefile~wav_file_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-30 ! Last modifications: 2024-06-02 !> Arpeggios played in various ways using the circles of fifths !> https://en.wikipedia.org/wiki/Arpeggio program arpeggios use forsynth , only : wp use wav_file_class , only : WAV_file use music_common , only : MINOR_CHORD , MAJOR_CHORD , & & CIRCLE_OF_FIFTHS_MAJOR , CIRCLE_OF_FIFTHS_MINOR use music , only : add_chord , add_broken_chord , fr , SEMITONE use signals , only : add_karplus_strong use envelopes , only : apply_fade_out implicit none type ( WAV_file ) :: demo integer :: i real ( wp ) :: t , dur character ( 3 ) :: name print * , \"**** Demo arpeggios ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'arpeggios.wav' , tracks = 2 , duration = 4 0._wp ) associate ( tape => demo % tape_recorder ) ! Chord duration in seconds: dur = 0.75_wp print * , \"Track 1: the circle of fifths major (left channel, octave 2)\" t = 0.0_wp do i = 1 , size ( CIRCLE_OF_FIFTHS_MAJOR ) name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" print * , i , name , fr ( name ) call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ) t = t + dur end do print * , \"The same, but the notes of each chord are played in an inverted order\" do i = 1 , size ( CIRCLE_OF_FIFTHS_MAJOR ) name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" print * , i , name , fr ( name ) call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ( 3 : 1 : - 1 )) t = t + dur end do print * , \"Counterclockwise, the circle of fourths\" do i = size ( CIRCLE_OF_FIFTHS_MAJOR ), 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ) t = t + dur end do print * , \"Once again, half the circle, slower and slower, with inverted arpeggios\" do i = size ( CIRCLE_OF_FIFTHS_MAJOR ) / 2 , 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MAJOR ( i )) // \"2\" call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ( 3 : 1 : - 1 )) t = t + dur dur = dur * 1.1_wp end do print * , \"We repeat the final chord\" call add_broken_chord ( tape , track = 1 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MAJOR_CHORD ( 3 : 1 : - 1 )) call add_karplus_strong ( tape , track = 1 , t1 = t + dur , t2 = t + 5 * dur , f = fr ( name ) * SEMITONE ** MAJOR_CHORD ( 3 ), Amp = 1.0_wp ) print * , \"Track 2: the circle of fifths minor (right channel, octave 3)\" dur = 0.75_wp t = 0.0_wp do i = 1 , size ( CIRCLE_OF_FIFTHS_MINOR ) name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ) t = t + dur end do print * , \"The same, but the notes of each chord are played in an inverted order\" do i = 1 , size ( CIRCLE_OF_FIFTHS_MINOR ) name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ( 3 : 1 : - 1 )) t = t + dur end do print * , \"Counterclockwise, the circle of fourths\" do i = size ( CIRCLE_OF_FIFTHS_MINOR ), 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ) t = t + dur end do print * , \"Once again, half the circle, slower and slower, with inverted arpeggios\" do i = size ( CIRCLE_OF_FIFTHS_MINOR ) / 2 , 1 , - 1 name = trim ( CIRCLE_OF_FIFTHS_MINOR ( i )) // \"3\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ( 3 : 1 : - 1 )) t = t + dur dur = dur * 1.1_wp end do print * , \"We repeat the final chord and the final note\" call add_broken_chord ( tape , track = 2 , t1 = t , t2 = t + dur , f = fr ( name ), Amp = 1.0_wp , chord = MINOR_CHORD ( 3 : 1 : - 1 )) call add_karplus_strong ( tape , track = 2 , t1 = t + dur , t2 = t + 5 * dur , f = fr ( name ) * SEMITONE ** MINOR_CHORD ( 3 ), Amp = 1.0_wp ) print * , \"Final fade out\" call apply_fade_out ( tape , track = 1 , t1 = t + dur , t2 = t + 5 * dur ) call apply_fade_out ( tape , track = 2 , t1 = t + dur , t2 = t + 5 * dur ) end associate print * , \"Final mix...\" ! In the mix, chords are rather on the left ! and plucked strings on the right (and their level is lowered): call demo % mix_tracks ( levels = [ 1._wp , 1.2_wp ], pan = [ - 0.5_wp , + 0.5_wp ]) call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program arpeggios","tags":"","loc":"sourcefile/arpeggios.f90.html"},{"title":"shepard_scale.f90 – ForSynth","text":"This file depends on sourcefile~~shepard_scale.f90~~EfferentGraph sourcefile~shepard_scale.f90 shepard_scale.f90 sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~shepard_scale.f90->sourcefile~audio_effects.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~shepard_scale.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~shepard_scale.f90->sourcefile~wav_file_class.f90 sourcefile~audio_effects.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-20 ! Last modifications: 2024-05-31 !> A Shepard scale, giving the illusion of an ever increasing pitch in the first !> half of the tape and an ever decreasing pitch in the 2nd half. !> Shepard, Roger N. \"Circularity in Judgments of Relative Pitch\", !> The Journal of the Acoustical Society of America 36, no. 12, !> (December 1, 1964): 2346–53. https://doi.org/10.1121/1.1919362. !> https://en.wikipedia.org/wiki/Shepard_tone program shepard_scale use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use audio_effects , only : apply_reverse_effect implicit none type ( WAV_file ) :: demo ! Time in seconds: real ( wp ) :: ti , ti0 ! Pulsation (radians/second): real ( wp ) :: omega real ( wp ) :: Amp integer :: i , k !-------------------------- ! Shepard scale parameters: !-------------------------- ! t th tone: integer :: t integer , parameter :: tmax = 12 ! Components of each tone: integer :: c ! The number of components was 10 in the paper, but the bandwidth was ! 5 kHz instead of 20 kHz. We have therefore added two octaves: integer , parameter :: cmax = 12 ! Sound pressure levels in dB for the components: real ( wp ) :: L real ( wp ), parameter :: Lmin = 2 2._wp real ( wp ), parameter :: Lmax = 5 6._wp ! Frequency of the lowest component of the first tone: real ( wp ), parameter :: fmin = 4.863_wp ! D# ! Duration of a tone and of the following silence: real ( wp ), parameter :: d = 0.125_wp real ( wp ), parameter :: ds = 0.840_wp real ( wp ) :: teta , f ! Number of repetitions: integer , parameter :: kmax = 9 print * , \"**** Creating shepard_scale.wav ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'shepard_scale.wav' , tracks = 1 , duration = 12 0._wp ) associate ( tape => demo % tape_recorder ) ! Repeat the Shepard scale: do k = 0 , kmax ! Tones loop: do t = 1 , tmax ! Components loop: do c = 1 , cmax ! Equations from the Shepard paper: f = fmin * 2._wp ** ((( c - 1 ) * tmax + t - 1 ) / real ( tmax , kind = wp )) omega = 2 * PI * f teta = ( 2 * PI * ( c - 1 ) * tmax + t - 1 ) / ( tmax * cmax ) L = Lmin + ( Lmax - Lmin ) * ( 1._wp - cos ( teta )) / 2._wp ! Converting dB to linear amplitude: Amp = 1 0._wp ** ( L / 2 0._wp ) ! Writing a sinusoidal signal at ti0, for a duration d. ! We do not write silences (the tape is initially silent). ti0 = k * tmax * ( d + ds ) + t * ( d + ds ) ti = ti0 do i = nint ( ti0 * RATE ), nint (( ti0 + d ) * RATE ) - 1 tape % left ( 1 , i ) = tape % left ( 1 , i ) + Amp * sin ( omega * ti ) ti = ti + dt end do end do end do end do tape % right = tape % left ! The 2nd half of the track is reversed to obtain an ever decreasing pitch: call apply_reverse_effect ( tape , track = 1 , t1 = ( 1 + kmax ) / 2 * tmax * ( d + ds ), t2 = ( 1 + kmax ) * tmax * ( d + ds ) + d ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program shepard_scale","tags":"","loc":"sourcefile/shepard_scale.f90.html"},{"title":"shepard_risset_glissando.f90 – ForSynth","text":"This file depends on sourcefile~~shepard_risset_glissando.f90~~EfferentGraph sourcefile~shepard_risset_glissando.f90 shepard_risset_glissando.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~wav_file_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin, 2024-05-24 ! Last modifications: 2024-06-03 !> A Shepard-Risset glissando, giving the illusion of an ever increasing pitch. !> It is the continuous version of the Shepard scale. !> It is not perfect, as we can hear that globally the whole is getting slowly !> higher. It is also visible when zooming in the waveform woth audacity. !> Some kind of beating might occur due to the fact that in the sin(), !> both omega and t are varying at each step. But as the f() are now redefined !> regularly, things are unclear for the moment... !> https://en.wikipedia.org/wiki/Shepard_tone program shepard_risset_glissando use forsynth , only : wp , dt , RATE , PI use wav_file_class , only : WAV_file use envelopes , only : apply_fade_in , apply_fade_out implicit none type ( WAV_file ) :: demo ! Pulsation (radians/second): real ( wp ) :: omega real ( wp ) :: t real ( wp ) :: Amp integer :: i , j !-------------------------- ! Glissando parameters: !-------------------------- ! Bandwidth 20-20480 Hz: 10 octaves integer , parameter :: cmax = 10 real ( wp ), parameter :: fmin = 2 0._wp real ( wp ), parameter :: fmax = fmin * 2 ** cmax ! Frequencies of each component: real ( wp ) :: f ( cmax ) ! Gaussian window, central frequency in log scale, with a shift: real ( wp ), parameter :: muf = (( log10 ( fmin ) + log10 ( fmax )) / 2 ) - 0.3 ! Standard deviation (very important for a good result): real ( wp ), parameter :: sigma = 0.25_wp ! Total duration of the WAV: real ( wp ), parameter :: length = 12 0._wp ! Setting the increase rate: real ( wp ), parameter :: d = 1 6._wp real ( wp ), parameter :: increase = 2 ** ( + 1 / ( d * RATE )) logical :: restart ! Useful for debugging and setting the envelope parameters: !call write_amplitude_envelope() ! Initializing the components, separated by octaves: call initialize_frequencies () print * , \"Frequencies:\" , f print * , \"Log Central frequency:\" , muf print * , \"Pitch increase:\" , increase print * , \"**** Creating shepard_risset_glissando.wav ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'shepard_risset_glissando.wav' , tracks = 1 , duration = length ) associate ( tape => demo % tape_recorder ) do i = 0 , nint ( length * RATE ) - 1 t = i * dt ! Computing and adding each component on the track: do j = 1 , cmax omega = 2 * PI * f ( j ) ! Amplitude of the signal (gaussian distribution): Amp = amplitude ( f ( j )) tape % left ( 1 , i ) = tape % left ( 1 , i ) + Amp * sin ( omega * t ) end do ! Increasing pitch of each component: f = f * increase restart = . false . ! Each component must stay between fmin and fmax: if ( maxval ( f ) >= fmax ) restart = . true . ! Would be useful for a decreasing glissando: if ( minval ( f ) <= fmin ) restart = . true . ! As each component is separated by one octave, we can ! redefine all the components as they were at t=0, each time one has ! passed the last octave. In that way, we are sure they won't diverge ! at all due to numerical problems: if ( restart ) then call initialize_frequencies end if end do tape % right = tape % left call apply_fade_in ( tape , track = 1 , t1 = 0._wp , t2 = 1._wp ) call apply_fade_out ( tape , track = 1 , t1 = length - 1 , t2 = length ) end associate ! All tracks will be mixed on track 0. ! Needed even if there is only one track! call demo % mix_tracks () call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () contains subroutine initialize_frequencies () integer :: j do j = 1 , cmax f ( j ) = fmin * 2 ** ( j - 1 ) end do end subroutine !> Returns an amplitude rising from 0 to 1, from f1 to f2. And 0 outside. real ( wp ) function linear1 ( freq , f1 , f2 ) real ( wp ), intent ( in ) :: freq , f1 , f2 if (( f1 <= freq ). and .( freq <= f2 )) then linear1 = ( freq - f1 ) / ( f2 - f1 ) else linear1 = 0 end if end function !> Returns an amplitude falling from 1 to 0, from f1 to f2. And 0 outside. real ( wp ) function linear2 ( freq , f1 , f2 ) real ( wp ), intent ( in ) :: freq , f1 , f2 if (( f1 <= freq ). and .( freq <= f2 )) then linear2 = ( freq - f2 ) / ( f1 - f2 ) else linear2 = 0 end if end function !> Envelope of the glissando. A gaussian, plus linear sections at !> the extremities, to reach the 0 level. real ( wp ) function amplitude ( freq ) real ( wp ), intent ( in ) :: freq real ( wp ) :: Amp if ( freq <= 2 * fmin ) then Amp = linear1 ( freq , fmin , 2 * fmin ) else if ( freq >= fmax / 2 ) then Amp = linear2 ( freq , fmax / 2 , fmax ) else Amp = 1 end if amplitude = Amp * ( 1 / ( sqrt ( 2 * PI ) * sigma )) * exp ( - ( log10 ( freq ) - muf ) ** 2 / ( 2 * sigma ** 2 )) end function !> Useful for debugging and setting the envelope parameters: subroutine write_amplitude_envelope () real ( wp ) :: freq integer :: u integer , parameter :: points = 500 print * , muf , \" muf = \" , 10 ** muf open ( newunit = u , file = \"glissando_envelope.txt\" , status = 'replace' , action = 'write' ) do i = 1 , points freq = fmin + i * ( fmax - fmin ) / points write ( u , * ) freq , amplitude ( freq ) end do close ( u ) end subroutine end program shepard_risset_glissando","tags":"","loc":"sourcefile/shepard_risset_glissando.f90.html"},{"title":"chords_and_melody.f90 – ForSynth","text":"This file depends on sourcefile~~chords_and_melody.f90~~EfferentGraph sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~audio_effects.f90 audio_effects.f90 sourcefile~chords_and_melody.f90->sourcefile~audio_effects.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~chords_and_melody.f90->sourcefile~envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~chords_and_melody.f90->sourcefile~forsynth.f90 sourcefile~music.f90 music.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~music_common.f90 music_common.f90 sourcefile~chords_and_melody.f90->sourcefile~music_common.f90 sourcefile~signals.f90 signals.f90 sourcefile~chords_and_melody.f90->sourcefile~signals.f90 sourcefile~wav_file_class.f90 wav_file_class.f90 sourcefile~chords_and_melody.f90->sourcefile~wav_file_class.f90 sourcefile~audio_effects.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~audio_effects.f90->sourcefile~tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~forsynth.f90 sourcefile~music.f90->sourcefile~music_common.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~music.f90->sourcefile~tape_recorder_class.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~forsynth.f90 sourcefile~signals.f90->sourcefile~tape_recorder_class.f90 sourcefile~wav_file_class.f90->sourcefile~forsynth.f90 sourcefile~wav_file_class.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2024-06-02 !> A sequence of synth chords is repeated, and the corresponding notes are played !> randomly by plucked strings. program chords_and_melody use forsynth , only : wp use wav_file_class , only : WAV_file use signals , only : add_karplus_strong use music_common , only : MINOR_CHORD , MAJOR_CHORD use music , only : add_chord , fr use audio_effects , only : apply_delay_effect use envelopes , only : ADSR_envelope implicit none type ( WAV_file ) :: demo type ( ADSR_envelope ) :: env integer :: i real ( wp ) :: t , dnote , r real ( wp ) :: chosen_note ( 0 : 3 ) print * , \"**** Demo chords and melody ****\" ! We create a new WAV file, and define the number of tracks and its duration: call demo % create_WAV_file ( 'chords_and_melody.wav' , tracks = 2 , duration = 12 0._wp ) ! We create an ADSR envelope that will be passed to signals (add_chord): call env % new ( A = 1 5._wp , D = 4 0._wp , S = 8 0._wp , R = 1 5._wp ) ! Notes duration in seconds: dnote = 3.0_wp associate ( tape => demo % tape_recorder ) print * , \"Track 1: repeating Am C G Dm chords...\" t = 0.0_wp call add_chord ( tape , track = 1 , t1 = t , t2 = t + dnote , f = fr ( \"A3\" ), Amp = 1.0_wp , chord = MINOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + dnote , t2 = t + 2 * dnote , f = fr ( \"C3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 2 * dnote , t2 = t + 3 * dnote , f = fr ( \"G3\" ), Amp = 1.0_wp , chord = MAJOR_CHORD , envelope = env ) call add_chord ( tape , track = 1 , t1 = t + 3 * dnote , t2 = t + 4 * dnote , f = fr ( \"D3\" ), Amp = 1.0_wp , chord = MINOR_CHORD , envelope = env ) ! Repeat those four chords until the end of the track: do i = 1 , 9 call demo % copy_section ( from_track = 1 , to_track = 1 , t1 = t , t2 = t + 4 * dnote , t3 = 4 * dnote * i ) end do print * , \"Track 2: playing random A C G D notes using plucked strings...\" dnote = dnote / 4 ! An array of notes that can be played: chosen_note ( 0 ) = fr ( \"A3\" ) chosen_note ( 1 ) = fr ( \"C3\" ) chosen_note ( 2 ) = fr ( \"G3\" ) chosen_note ( 3 ) = fr ( \"D3\" ) do i = 0 , 9 * 16 t = dnote * i call random_number ( r ) call add_karplus_strong ( tape , track = 2 , t1 = t , t2 = t + dnote , f = chosen_note ( int ( r * 4 )), Amp = 1._wp ) end do ! A double delay inspired by The Edge. ! Dotted quavers delay: call apply_delay_effect ( tape , track = 2 , t1 = 0.0_wp , t2 = demo % duration , delay = dnote * 0.75_wp , Amp = 0.45_wp ) ! Plus a quavers delay: call apply_delay_effect ( tape , track = 2 , t1 = 0.0_wp , t2 = demo % duration , delay = dnote * 0.50_wp , Amp = 0.30_wp ) end associate print * , \"Final mix...\" ! In the mix, chords are rather on the left ! and plucked strings on the right (and their level is lowered): call demo % mix_tracks ( levels = [ 1._wp , 0.75_wp ], pan = [ - 0.5_wp , + 0.5_wp ]) call demo % close_WAV_file () print * , \"You can now play the file \" , demo % get_name () end program chords_and_melody","tags":"","loc":"sourcefile/chords_and_melody.f90.html"},{"title":"envelopes.f90 – ForSynth","text":"This file depends on sourcefile~~envelopes.f90~~EfferentGraph sourcefile~envelopes.f90 envelopes.f90 sourcefile~forsynth.f90 forsynth.f90 sourcefile~envelopes.f90->sourcefile~forsynth.f90 sourcefile~tape_recorder_class.f90 tape_recorder_class.f90 sourcefile~envelopes.f90->sourcefile~tape_recorder_class.f90 sourcefile~tape_recorder_class.f90->sourcefile~forsynth.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~envelopes.f90~~AfferentGraph sourcefile~envelopes.f90 envelopes.f90 sourcefile~all_signals.f90 all_signals.f90 sourcefile~all_signals.f90->sourcefile~envelopes.f90 sourcefile~music.f90 music.f90 sourcefile~all_signals.f90->sourcefile~music.f90 sourcefile~signals.f90 signals.f90 sourcefile~all_signals.f90->sourcefile~signals.f90 sourcefile~arpeggios.f90 arpeggios.f90 sourcefile~arpeggios.f90->sourcefile~envelopes.f90 sourcefile~arpeggios.f90->sourcefile~music.f90 sourcefile~arpeggios.f90->sourcefile~signals.f90 sourcefile~chords_and_melody.f90 chords_and_melody.f90 sourcefile~chords_and_melody.f90->sourcefile~envelopes.f90 sourcefile~chords_and_melody.f90->sourcefile~music.f90 sourcefile~chords_and_melody.f90->sourcefile~signals.f90 sourcefile~demo_effects.f90 demo_effects.f90 sourcefile~demo_effects.f90->sourcefile~envelopes.f90 sourcefile~demo_effects.f90->sourcefile~music.f90 sourcefile~drone_music.f90 drone_music.f90 sourcefile~drone_music.f90->sourcefile~envelopes.f90 sourcefile~drone_music.f90->sourcefile~music.f90 sourcefile~music.f90->sourcefile~envelopes.f90 sourcefile~music.f90->sourcefile~signals.f90 sourcefile~radioactivity.f90 radioactivity.f90 sourcefile~radioactivity.f90->sourcefile~envelopes.f90 sourcefile~radioactivity.f90->sourcefile~music.f90 sourcefile~morse_code.f90 morse_code.f90 sourcefile~radioactivity.f90->sourcefile~morse_code.f90 sourcefile~shepard_risset_glissando.f90 shepard_risset_glissando.f90 sourcefile~shepard_risset_glissando.f90->sourcefile~envelopes.f90 sourcefile~signals.f90->sourcefile~envelopes.f90 sourcefile~blues.f90 blues.f90 sourcefile~blues.f90->sourcefile~music.f90 sourcefile~blues.f90->sourcefile~signals.f90 sourcefile~drum_machine.f90 drum_machine.f90 sourcefile~drum_machine.f90->sourcefile~signals.f90 sourcefile~misc_sounds.f90 misc_sounds.f90 sourcefile~misc_sounds.f90->sourcefile~music.f90 sourcefile~morse_code.f90->sourcefile~signals.f90 sourcefile~multiplication_bells.f90 multiplication_bells.f90 sourcefile~multiplication_bells.f90->sourcefile~music.f90 sourcefile~multiplication_bells.f90->sourcefile~signals.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Forsynth: a multitracks stereo sound synthesis project ! License GPL-3.0-or-later ! Vincent Magnin ! Last modifications: 2025-02-12 !> Functions and subroutines generating envelopes module envelopes use forsynth , only : wp , RATE use tape_recorder_class implicit none type ADSR_envelope !> A   D S   R !>    /\\ !>   /  \\____ !>  /        \\ !> /          \\ !> https://en.wikipedia.org/wiki/Envelope_(music) !> Default parameters of the ADSR envelope: real ( wp ) :: attack = 3 0.0_wp ! duration % real ( wp ) :: decay = 2 0.0_wp ! duration % real ( wp ) :: sustain = 8 0.0_wp ! max level % real ( wp ) :: release = 3 0.0_wp ! duration % contains procedure :: new => ADSR_new procedure :: get_level => ADSR_level end type ADSR_envelope private public :: ADSR_envelope , apply_fade_in , apply_fade_out , fit_exp contains subroutine ADSR_new ( self , A , D , S , R ) class ( ADSR_envelope ), intent ( inout ) :: self real ( wp ), intent ( in ) :: A , D , S , R self % attack = A self % decay = D self % sustain = S self % release = R end subroutine ADSR_new !> Returns the level in [0, 1] of the ADSR envelope at time t1 < t < t2 pure real ( wp ) function ADSR_level ( self , t , t1 , t2 ) class ( ADSR_envelope ), intent ( in ) :: self real ( wp ), intent ( in ) :: t , t1 , t2 integer :: i , i1 , i2 , i3 , i4 , i5 i = nint ( t * RATE ) ! First part (Attack): i1 = nint ( t1 * RATE ) i2 = nint (( t1 + ( t2 - t1 ) * self % attack / 10 0.0_wp ) * RATE ) if (( i >= i1 ) . and . ( i < i2 )) then ADSR_level = ( i - i1 ) / real ( i2 - i1 , wp ) else i3 = nint (( t1 + ( t2 - t1 ) * ( self % attack + self % decay ) / 10 0.0_wp ) * RATE ) if (( i >= i2 ) . and . ( i < i3 )) then ADSR_level = ( 10 0.0_wp - ( i - i2 ) / real ( i3 - i2 , wp ) * & & ( 10 0.0_wp - self % sustain )) / 10 0.0_wp else i4 = nint (( t2 - ( t2 - t1 ) * self % release / 10 0.0_wp ) * RATE ) if (( i >= i3 ) . and . ( i < i4 )) then ADSR_level = ( self % sustain / 10 0.0_wp ) else i5 = nint ( t2 * RATE ) if (( i >= i4 ) . and . ( i <= i5 )) then ADSR_level = ( self % sustain - ( i - i4 ) / real ( i5 - i4 , wp ) * & & self % sustain ) / 10 0.0_wp else ! ERROR ADSR_level: t outside [t1, t2] ADSR_level = 1.0_wp end if end if end if end if end function ADSR_level !> A linear fade in, from relative level 0 to 1: subroutine apply_fade_in ( tape , track , t1 , t2 ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 integer :: i , i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 do concurrent ( i = i1 : i2 ) tape % left ( track , i ) = tape % left ( track , i ) * ( i - i1 ) / ( i2 - i1 ) tape % right ( track , i ) = tape % right ( track , i ) * ( i - i1 ) / ( i2 - i1 ) end do end subroutine apply_fade_in !> A linear fade out, from relative level 1 to 0: subroutine apply_fade_out ( tape , track , t1 , t2 ) type ( tape_recorder ), intent ( inout ) :: tape integer , intent ( in ) :: track real ( wp ), intent ( in ) :: t1 , t2 integer :: i , i1 , i2 i1 = nint ( t1 * RATE ) i2 = nint ( t2 * RATE ) - 1 do concurrent ( i = i1 : i2 ) tape % left ( track , i ) = tape % left ( track , i ) * (( i - i2 ) / real ( i1 - i2 , kind = wp )) tape % right ( track , i ) = tape % right ( track , i ) * (( i - i2 ) / real ( i1 - i2 , kind = wp )) end do end subroutine apply_fade_out !> Returns an exponential interpolation y(x) between (x1,y1) and (x2,y2). !> Useful for computing an exponentially decreasing enveloppe. real ( wp ) pure function fit_exp ( x , x1 , y1 , x2 , y2 ) real ( wp ), intent ( in ) :: x , x1 , y1 , x2 , y2 fit_exp = y1 ** (( x - x2 ) / ( x1 - x2 )) * y2 ** (( x - x1 ) / ( x2 - x1 )) end function end module envelopes","tags":"","loc":"sourcefile/envelopes.f90.html"}]}